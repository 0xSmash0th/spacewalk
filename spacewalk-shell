#!/usr/bin/python

# RFEs:
# configchannel.listSubscribedSystems

import atexit, logging, os, re, readline, sys, textwrap, xmlrpclib
from cmd import Cmd
from getpass import getpass
from optparse import Option, OptionParser
from pwd import getpwuid

class SpacewalkShell(Cmd):
    MINIMUM_API_VERSION = 10.8

    HISTORY_LENGTH = 1024
  
    ENTITLEMENTS = {'provisioning_entitled'        : 'Provisioning',
                    'enterprise_entitled'          : 'Management',
                    'monitoring_entitled'          : 'Monitoring',
                    'virtualization_host'          : 'Virtualization',
                    'virtualization_host_platform' : 'Virtualization Platform'}

    intro = """
Welcome to SpacewalkShell, a command line interface to Spacewalk.

For a full set of commands, type "help" on the prompt.
For help for a specific command try "help <cmd>".
"""
    cmdqueue = []
    completekey = "tab"
    stdout = sys.stdout
    prompt = 'Spacewalk> '

    emptyline = lambda self: None

    def __init__(self, options):
        self.session = ''
        self.ssm = {}

        # make the options available everywhere
        self.options = options

        userinfo = getpwuid(os.getuid())
        self.cache_file = os.path.join(userinfo[5], ".spacewalk_cache")
        self.history_file = os.path.join(userinfo[5], ".spacewalk_history")

        try:
            # don't split on hyphens during tab completion
            newdelims = readline.get_completer_delims().replace('-', '')
            readline.set_completer_delims(newdelims)
        
            if not options.nohistory:
                try:
                    readline.read_history_file(self.history_file)
                    readline.set_history_length(self.HISTORY_LENGTH)

                    # always write the history file on exit
                    atexit.register(readline.write_history_file,
                                    self.history_file)
                except:
                    logging.error("Could not read history file")
                    logging.debug(sys.exc_info())
        except:
            logging.debug(sys.exc_info())
            pass


    # load the history file
    def preloop(self):
        if not self.session:
            self.args = []
            self.do_login(self.args)


    # handle commands that exit the shell
    def precmd(self, line):
        # set the command and arguments once so they can be used elsewhere
        try:
            parts = line.split()
            self.cmd = parts[0]
            self.args = parts[1:]
        except IndexError:
            self.cmd = ''
            self.args = []
 
        if self.cmd.lower() in ('quit', 'exit', 'eof'):
            print
            sys.exit(0)
        else:
            return line

###########

    def tab_completer(self, options, text):
        return [o for o in options if o.startswith(text)]
    
    def filter_results(self, list, args):
        patterns = []
        for pattern in args:
            patterns.append(re.compile(pattern, re.IGNORECASE))

        matches = []
        for item in list:
            if len(patterns) > 0:
                for pattern in patterns:
                    if pattern.search(item):
                        matches.append(item)
            else:
                matches.append(item)

        matches.sort()
        return matches

    def build_package_names(self, packages):
        new_packages = []
        for p in packages:
            package = p.get('name') + '-' \
                    + p.get('version') + '-' \
                    + p.get('release')

            if p.get('epoch') != ' ' and p.get('epoch') != '':
                package = package + ':' + p.get('epoch')

            if p.get('arch'):
                package = package + '.' + p.get('arch')
            elif p.get('arch_label'):
                package = package + '.' + p.get('arch_label')

            new_packages.append(package)
           
        packages = new_packages
        packages.sort()

        return packages

    def get_system_id(self, name):
        systems = self.client.system.getId(self.session, name)

        if len(systems) == 0:
            logging.error("No systems found")
            return
        elif len(systems) == 1:
            return systems[0].get('id')
        else:
            logging.warning("Multiple systems found with the same name")

            for system in systems:
                logging.warning(name + " = " + str(system.get('id'))) 

            return

###########

    def help_ssm_add(self):
        print "Usage: ssm_add SYSTEM [SYSTEM] ..."

    def complete_ssm_add(self, text, line, begidx, endidx):
        return self.tab_completer(self.do_system_list('', True, False), text)

    def do_ssm_add(self, args):
        all_systems = {}
        for s in self.client.system.listSystems(self.session):
            all_systems[s.get('name')] = s.get('id')

        matches = self.filter_results(all_systems.keys(), self.args)

        if len(matches) == 0:
            logging.warning("No systems found")
            return

        for match in matches:
            if match in self.ssm.keys():
                logging.warning(match + " is already in the SSM")
                continue
            else:             
                logging.info("Added " + match + " to the SSM")
                logging.debug("System ID: " + str(all_systems.get(match)))
                self.ssm[match] = all_systems.get(match)


    def help_ssm_rm(self):
        print "Usage: ssm_rm SYSTEM [SYSTEM] ..."
    
    def complete_ssm_rm(self, text, line, begidx, endidx):
        return self.tab_completer(self.do_ssm_list('', True), text)

    def do_ssm_rm(self, args):
        matches = self.filter_results(self.ssm.keys(), self.args)
        
        if len(matches) == 0:
            logging.warning("No matches found in the SSM")
            return

        for match in matches:
            logging.info("Deleting " + match + " from the SSM")
            del self.ssm[match]
            
 
    def help_ssm_list(self):
        print "Usage: ssm_list"
    
    def do_ssm_list(self, args, doreturn=False):
        systems = sorted(self.ssm.keys())

        if doreturn:
            return systems
        else:
            print "\n".join(systems)


    def help_ssm_clear(self):
        print "Usage: ssm_clear"
    
    def do_ssm_clear(self, args):
        self.ssm.clear()

###########

    def help_help(self):
        print "Usage: help COMMAND"

    def help_clear(self):
        print "Usage: clear"
    
    def do_clear(self, args):
        os.system('clear')

###########

    def help_login(self):
        print "Usage: login [USERNAME] [SERVER]"

    def do_login(self, args):
        self.session = ''
        
        if self.options.nossl:
            proto = "http"
        else:
            proto = "https"

        if len(self.args) == 2 and self.args[1]:
            server = self.args[1]
        elif self.options.server:
            server = self.options.server
        else:
            logging.error("No server specified")
            return

        server = proto + "://" + server + "/rpc/api"

        # connect to the server
        logging.debug("Connecting to " + server)
        self.client = xmlrpclib.Server(server)

        try:
            api_version = self.client.api.getVersion()
        except:
            self.client = None
            logging.error(sys.exc_info()[1])
            logging.debug(sys.exc_info())
            return

        # ensure the server is recent enough
        if api_version < self.MINIMUM_API_VERSION:
            logging.error("API (" + api_version + ") is too old (>= " \
                         + self.MINIMUM_API_VERSION + " required)")

            self.client = None
            return

        # retrieve a cached session
        if not self.options.nocache:
            if os.path.isfile(self.cache_file):
                try:
                    # read the session (format = username:session)
                    sessionfile = open(self.cache_file, "r")
                    parts = sessionfile.read().split(':')
                    sessionfile.close()
   
                    username = parts[0]
                    self.session = parts[1]
                except:
                    logging.error("Could not read " + self.cache_file)
                    logging.debug(sys.exc_info())

                try:
                    logging.info("Using cached credentials from " + \
                                 self.cache_file)

                    self.client.user.listUsers(self.session)
                except:
                    logging.warning("Cached credentials are invalid")
                    self.session = ''

                    try:
                        os.remove(self.cache_file)
                    except:
                        logging.debug(sys.exc_info())
                        pass
        
        # attempt to login if we don't have a valid session yet    
        if not self.session:
            if self.options.username:
                username = self.options.username
                self.options.username = None
            elif len(self.args) > 0 and self.args[0]:
                username = self.args[0]
            else:
                username = raw_input("Username: ")

                # don't store the username in the command history
                last = readline.get_current_history_length() - 1
                readline.remove_history_item(last)

            if self.options.password:
                password = self.options.password
                self.options.password = None
            else:
                password = getpass("Password: ")

            try:
                self.session = self.client.auth.login(username, 
                                                      password)
                self.username = username
            except:
                logging.error("Invalid credentials")
                logging.debug(sys.exc_info())
                return

            # write the session to a cache
            if not self.options.nocache:
                try:
                    logging.debug("Writing session cache to " + self.cache_file) 
                    sessionfile = open(self.cache_file, "w")
                    sessionfile.write(username + ':' + self.session)
                    sessionfile.close()
                except:
                    logging.error("Could not write cache file")
                    logging.debug(sys.exc_info())
 
        # disable caching of subsequent logins
        self.options.nocache = True

        logging.info("Connected to " + server + " as " + username)

###########

    def help_logout(self):
        print "Usage: logout"
        
    def do_logout(self, args):
        if self.session:
            self.client.auth.logout(self.session)
            self.session = ''
            self.username = ''
            
            try:
                os.remove(self.cache_file)
            except:
                logging.debug(sys.exc_info())
                pass
        else:
            logging.error("You're not logged in")

###########

    def help_whoami(self):
        print "Usage: whoami"

    def do_whoami(self, args):
        print self.username

###########

    def help_get_apiversion(self):
        print "Usage: get_apiversion"


    def do_get_apiversion(self, args):
        print self.client.api.getVersion()

###########

    def help_get_serverversion(self):
        print "Usage: get_serverversion"

    def do_get_serverversion(self, args):
        print self.client.api.systemVersion()

###########

    def help_get_certificateexpiration(self):
        print "Usage: get_certificateexpiration"

    def do_get_certificateexpiration(self, args):
        print self.client.satellite.getCertificateExpirationDate(self.session).value

###########

    def help_get_entitlements(self):
        print "Usage: get_entitlements"

    def do_get_entitlements(self, args):
        entitlements = self.client.satellite.listEntitlements(self.session)

        print "System:"
        for e in entitlements.get('system'):
            print e.get('label') + ": " + \
                  str(e.get('used_slots')) + "/" + str(e.get('total_slots'))

        print       
        print "Channel:"
        for e in entitlements.get('channel'):
            print e.get('label') + ": " + \
                  str(e.get('used_slots')) + "/" + str(e.get('total_slots'))

###########

    def help_package_details(self):
        print "Usage: package_details PACKAGE [PACKAGE] ..."        

    def do_package_details(self, args):
        add_separator = False

        for package in self.args:
            if add_separator:
                print "\n--------------------\n"

            add_separator = True

            try:
                id = int(package)
            except:
                id = self.client.packages.search.name(self.session,
                                                      package)[0].get('id')

            details = self.client.packages.getDetails(self.session, id)
            channels = self.client.packages.listProvidingChannels(self.session,
                                                                  id)

            print "Name:    " + details.get('name')
            print "Version: " + details.get('version')
            print "Release: " + details.get('release') 
            print "Epoch:   " + details.get('epoch')
            print "Arch:    " + details.get('arch_label')

            print
            print "Description: "
            print "\n".join(textwrap.wrap(details.get('description')))

            print
            print "File:    " + details.get('file')
            print "Size:    " + details.get('size')
            print "MD5:     " + details.get('md5sum')

            print
            print "Available From:"
            for channel in sorted([c.get('label') for c in channels]):
                print channel

###########

    def help_package_search(self):
        print "Usage: package_search QUERY"
        print "Available Fields: name, epoch, version, release, arch, " + \
              "description, summary"
        print "Example: name:kernel AND version:2.6.18 AND -description:devel" 

    def do_package_search(self, args):
        packages = self.client.packages.search.advanced(self.session, args)
        
        for p in packages:
            details = self.client.packages.getDetails(self.session, p.get('id'))
            print "Package: " + self.build_package_names([p])[0]

###########

    def help_system_list(self):
        print "Usage: system_list [PATTERN] [PATTERN] ..."
    
    def do_system_list(self, args, doreturn=False, filtered=True):
        systems = self.client.system.listSystems(self.session)
        systems = [s.get('name') for s in systems]

        if filtered:
            systems = self.filter_results(systems, self.args)

        if doreturn:
            return systems
        else:
            print "\n".join(sorted(systems))

###########

    def help_system_details(self):
        print "Usage: system_details SSM|SYSTEM"

    def complete_system_details(self, text, line, begidx, endidx):
        return self.tab_completer(self.do_system_list('', True, False), text)
 
    def do_system_details(self, args):
        if len(self.args) == 0:
            self.help_system_details()
            return

        add_separator = False

        if self.args[0].lower() == 'ssm':
            systems = self.ssm
        else:
            systems = self.args

        for system in systems:
            try:
                # check if we were passed a system ID
                system_id = int(system)
            except ValueError:
                system_id = self.get_system_id(system)

            if not system_id:
                logging.error(system + ' is not a valid system')
                continue

            last_checkin = \
                self.client.system.getName(self.session,
                                           system_id).get('last_checkin')

            details = self.client.system.getDetails(self.session, system_id)

            registered = self.client.system.getRegistrationDate(self.session,
                                                                system_id)
            
            entitlements = self.client.system.getEntitlements(self.session,
                                                              system_id)

            base_channel = \
                self.client.system.getSubscribedBaseChannel(self.session,
                                                            system_id)

            child_channels = \
                self.client.system.listSubscribedChildChannels(self.session,
                                                               system_id)

            groups = self.client.system.listGroups(self.session,
                                                   system_id)

            kernel = self.client.system.getRunningKernel(self.session,
                                                         system_id)
            
            config_channels = \
                self.client.system.config.listChannels(self.session,
                                                       system_id)

            ranked_config_channels = []
            for channel in config_channels:
                ranked_config_channels.append(channel.get('label'))
       
            if add_separator:
                print "\n--------------------\n"

            add_separator = True

            print "Name:          " + system
            print "System ID:     " + str(system_id)
            print "Locked:        " + str(details.get('lock_status'))
            print "Registered:    " + registered.value
            print "Last Checkin:  " + last_checkin.value
            print "Kernel:        " + kernel

            print
            print "Software Channels:"
            print '  ' + base_channel.get('label')

            for channel in child_channels:
                print "   |-- " + channel.get('label')

            print
            print 'Configuration Channels:'
            for channel in ranked_config_channels:
                print '  ' + channel

            print
            print "Entitlements:"
            for entitlement in sorted(entitlements):
                print '  ' + self.ENTITLEMENTS[entitlement]

            print
            print "System Groups:"
            for group in groups:
                if group.get('subscribed') == 1:
                    print '  ' + group.get('system_group_name')

###########

    def help_activationkey_list(self):
        print "Usage: activationkey_list [KEY] [KEY] ..."

    def do_activationkey_list(self, args, doreturn=False):
        keys = self.client.activationkey.listActivationKeys(self.session)
        keys = [k.get('key') for k in keys]

        if doreturn:
            return keys
        else:
            print "\n".join(self.filter_results(keys, self.args))

###########

    def help_activationkey_listsystems(self):
        print "Usage: activationkey_listsystems KEY"

    def complete_activationkey_listsystems(self, text, line, begidx, endidx):
        return self.tab_completer(self.do_activationkey_list('', True), text)

    def do_activationkey_listsystems(self, args):
        try:
            systems = \
                self.client.activationkey.listActivatedSystems(self.session,
                                                           self.args[0])
        except:
            logging.error(self.args[0] + ' is not a valid activation key')
            logging.debug(sys.exc_info())
            return
        
        systems = sorted([s.get('hostname') for s in systems])

        print "\n".join(systems)

###########
 
    def help_activationkey_details(self):
        print "Usage: activationkey_details KEY [KEY] ..."

    def complete_activationkey_details(self, text, line, begidx, endidx):
        return self.tab_completer(self.do_activationkey_list('', True), text)
 
    def do_activationkey_details(self, args):
        add_separator = False

        for key in self.args:
            try:
                details = self.client.activationkey.getDetails(self.session, 
                                                               key)

                config_channels = \
                    self.client.activationkey.listConfigChannels(self.session, 
                                                                 key) 
            except:
                logging.error(key + ' is not a valid activation key')
                logging.debug(sys.exc_info())
                return
     
            groups = []
            for group in details.get('server_group_ids'):
                group_details = self.client.systemgroup.getDetails(self.session,
                                                                   group)
                groups.append(group_details.get('name'))
        
            if add_separator:
                print "\n--------------------\n"
            
            add_separator = True

            print "Key:               " + details.get('key')
            print "Description:       " + details.get('description')
            print "Universal Default: " + str(details.get('universal_default'))

            print
            print "Software Channels:"
            print '  ' + details.get('base_channel_label')

            for channel in details.get('child_channel_labels'):
                print "   |-- " + channel

            print
            print 'Configuration Channels:'
            for channel in config_channels:
                print '  ' + channel.get('label')

            print
            print "Entitlements:"
            for entitlement in sorted(details.get('entitlements')):
                print '  ' + self.ENTITLEMENTS[entitlement]

            print
            print "System Groups:"
            for group in groups:
                print '  ' + group

            print
            print "Packages:"
            for package in details.get('packages'):
                name = package.get('name')

                if package.get('arch'):
                    name = name + '.' + package.get('arch')

                print '  ' + name

###########

    def help_configchannel_list(self):
        print "Usage: configchannel_list [CHANNEL] [CHANNEL] ..."

    def do_configchannel_list(self, args, doreturn=False):
        channels = self.client.configchannel.listGlobals(self.session)
        channels = [c.get('label') for c in channels]

        if doreturn:
            return channels
        else:
            print "\n".join(self.filter_results(channels, self.args))

###########

    def help_configchannel_listsystems(self):
        print "Usage: configchannel_listsystems CHANNEL"

    def complete_configchannel_listsystems(self, text, line, begidx, endidx):
        return self.tab_completer(self.do_configchannel_list('', True), text)

    def do_configchannel_listsystems(self, args):
        print "configchannel.listSubscribedSystems is not implemented"
        return

        systems = \
            self.client.configchannel.listSubscribedSystems(self.session,
                                                            self.args[0])
        
        systems = sorted([s.get('name') for s in systems])

        print "\n".join(systems)

###########
 
    def help_configchannel_details(self):
        print "Usage: configchannel_details CHANNEL [CHANNEL] ..."

    def complete_configchannel_details(self, text, line, begidx, endidx):
        return self.tab_completer(self.do_configchannel_list('', True), text)
 
    def do_configchannel_details(self, args):
        add_separator = False

        for channel in self.args:
            details = self.client.configchannel.getDetails(self.session, 
                                                           channel)
      
            files = self.client.configchannel.listFiles(self.session,
                                                        channel)
 
            if add_separator:
                print "\n--------------------\n"
            
            add_separator = True

            print "Label:       " + details.get('label')
            print "Name:        " + details.get('name')
            print "Description: " + details.get('description')

            print
            print "Files:"
            for file in files:
                print '  ' + file.get('path')

###########

    def help_softwarechannel_list(self):
        print "Usage: softwarechannel_list [CHANNEL] [CHANNEL] ..."

    def do_softwarechannel_list(self, args, doreturn=False):
        channels = self.client.channel.listAllChannels(self.session)
        channels = [c.get('label') for c in channels]

        if doreturn:
            return channels
        else:
            print "\n".join(self.filter_results(channels, self.args))
      
###########

    def help_softwarechannel_listsystems(self):
        print "Usage: softwarechannel_listsystems CHANNEL"

    def complete_softwarechannel_listsystems(self, text, line, begidx, endidx):
        return self.tab_completer(self.do_softwarechannel_list('', True), text)

    def do_softwarechannel_listsystems(self, args):
        systems = \
            self.client.channel.software.listSubscribedSystems(self.session,
                                                               self.args[0])
        
        systems = sorted([s.get('name') for s in systems])

        print "\n".join(systems)

###########

    def help_softwarechannel_packages(self):
        print "Usage: softwarechannel_packages CHANNEL [PACKAGE] [PACKAGE] ..."

    def complete_softwarechannel_packages(self, text, line, begidx, endidx):
        # only tab complete the channel name
        if len(line.split(' ')) == 2:
            return self.tab_completer(self.do_softwarechannel_list('', True), text)
        else:
            return []

    def do_softwarechannel_packages(self, args, doreturn=False):
        packages = self.client.channel.software.listLatestPackages(self.session,
                                                                   self.args[0])

        packages = self.build_package_names(packages)

        if doreturn:
            return packages
        else:
            print "\n".join(self.filter_results(packages, self.args[1:])) 
            
###########
 
    def help_softwarechannel_details(self):
        print "Usage: softwarechannel_details CHANNEL [CHANNEL] ..."

    def complete_softwarechannel_details(self, text, line, begidx, endidx):
        return self.tab_completer(self.do_softwarechannel_list('', True), text)
 
    def do_softwarechannel_details(self, args):
        add_separator = False

        for channel in self.args:
            details = self.client.channel.software.getDetails(self.session, 
                                                              channel)
      
            systems = \
                self.client.channel.software.listSubscribedSystems(self.session,                                                                   channel)
 
            if add_separator:
                print "\n--------------------\n"

            add_separator = True

            print "Label:              " + details.get('label')
            print "Name:               " + details.get('name')
            print "Architecture:       " + details.get('arch_name')
            print "Parent:             " + details.get('parent_channel_label')
            print "Summary:            " + details.get('summary')
            print "Systems Subscribed: " + str(len(systems))

            print
            print "Description:"
            print "\n".join(textwrap.wrap(details.get('description')))
           
            print 
            print "GPG Key:            " + details.get('gpg_key_id')
            print "GPG Fingerprint:    " + details.get('gpg_key_fp')
            print "GPG URL:            " + details.get('gpg_key_url')


###########

# parse the options and then start the command interpreter
if __name__ == "__main__":
    optionsTable = [
        Option('-u', '--username', action='store',
               help='Use this username to connect to RHN/Satellite'),
        Option('-p', '--password', action='store',
               help='Use this password to connect to RHN/Satellite'),
        Option('--server', action='store', default="localhost", 
               help='Connect to this server (http[s]://<hostname>/APP)'),
        Option('--nocache', action='store_true',
                help="Do not create a username/password cache"),
        Option('--nossl', action='store_true',
               help="Use HTTP instead of HTTPS"),
        Option('--nohistory', action='store_true',
                help="Do not store command history in ~/.spacewalk_history"),
        Option('-d', '--debug', action='store_true',
               help="Enable debug logging"),
    ]
    
    parser = OptionParser(option_list=optionsTable)
    (options, args) = parser.parse_args()
 
    if options.debug:
        log_level = logging.DEBUG
    else:
        log_level = logging.INFO


    # setup logging
    logging.basicConfig(level=log_level, 
                        format="%(levelname)s: %(message)s")

    # setup the shell
    shell = SpacewalkShell(options)

    # start the shell
    while True:
        try:
            shell.cmdloop()
        except xmlrpclib.Fault, err:
            shell.INTRO = ''
            logging.error(err.faultString.rsplit(': ', 1)[1])
            logging.debug(sys.exc_info())
        except KeyboardInterrupt:
            shell.INTRO = ''
            print

# vim:ts=4:expandtab:
