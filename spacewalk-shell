#!/usr/bin/python

import logging, os, re, sys, xmlrpclib
from cmd import Cmd
from getpass import getpass
from optparse import Option, OptionParser
from pwd import getpwuid

class SpacewalkShell(Cmd):
    MINIMUM_API_VERSION = 10.8
   
    def __init__(self, options):
        # set some defaults since we can't call our superclass constructor
        self.cmdqueue = []
        self.completekey = "tab"
        self.stdout = sys.stdout
        
        self.prompt = 'Spacewalk> '
       
        try:
            # don't split on hyphens during tab completion
            import readline
            newdelims = readline.get_completer_delims().replace('-', '')
            readline.set_completer_delims(newdelims)
        except:
            pass

        self.session = ''
        self.ssm = {}

        # make the options available everywhere
        self.options = options

        userinfo = getpwuid(os.getuid())
        self.cache_file = os.path.join(userinfo[5], ".spacewalk_cache")
        self.history_file = os.path.join(userinfo[5], ".spacewalk_history")

 
    # write the history file and exit 
    def terminate(self, exit_code=0):
        print

        if not self.options.nohistory:
            try:
                import readline
                readline.write_history_file(self.history_file)
            except:
                logging.error("Could not write history file")

        sys.exit(exit_code)

 
    def emptyline(self):
        pass


    # load the history file
    def preloop(self):
        if not options.nohistory:
            try:
                import readline
                readline.read_history_file(self.history_file)
            except:
                logging.error("Could not read history file")

        if not self.session:
            self.args = []
            self.do_login(self.args)


    # handle commands that exit the shell
    def precmd(self, line):
        # set the command and arguments once so they can be used elsewhere
        try:
            parts = line.split()
            self.cmd = parts[0]
            self.args = parts[1:]
        except IndexError:
            self.cmd = ''
            self.args = []
 
        if self.cmd.lower() in ('quit', 'exit', 'eof'):
            self.terminate()
        else:
            return line

###########

    def tab_completer(self, options, text):
        return [o for o in options if o.startswith(text)]
    
    def filter_results(self, list, args):
        patterns = []
        for pattern in args:
            patterns.append(re.compile(pattern, re.IGNORECASE))

        matches = []
        for item in list:
            if len(patterns) > 0:
                for pattern in patterns:
                    if pattern.search(item):
                        matches.append(item)
            else:
                matches.append(item)

        matches.sort()
        return matches

    def build_package_names(self, packages):
        new_packages = []
        for p in packages:
            package = p.get('name') + '-' \
                    + p.get('version') + '-' \
                    + p.get('release')

            if p.get('epoch') != ' ' and p.get('epoch') != '':
                package = package + ':' + p.get('epoch')

            if p.get('arch'):
                package = package + '.' + p.get('arch')
            elif p.get('arch_label'):
                package = package + '.' + p.get('arch_label')

            new_packages.append(package)
           
        packages = new_packages
        packages.sort()

        return packages

    def get_system_id(self, name):
        systems = self.client.system.getId(self.session, name)

        if len(systems) == 0:
            logging.error("No systems found")
            return
        elif len(systems) == 1:
            return systems[0].get('id')
        else:
            logging.warning("Multiple systems found with the same name")

            for system in systems:
                logging.warning(name + " = " + str(system.get('id'))) 

            return

###########

    def help_addtossm(self):
        print "Usage: addtossm SYSTEM1 [SYSTEM2] ..."

    def complete_addtossm(self, text, line, begidx, endidx):
        return self.tab_completer(self.do_listsystems('', True, False), text)

    def do_addtossm(self, args):
        all_systems = {}
        for s in self.client.system.listSystems(self.session):
            all_systems[s.get('name')] = s.get('id')

        matches = self.filter_results(all_systems.keys(), self.args)

        if len(matches) == 0:
            logging.warning("No systems found")
            return

        for match in matches:
            if match in self.ssm.keys():
                logging.warning(match + " is already in the SSM")
                continue
            else:             
                logging.info("Adding " + match + " to the SSM")
                logging.debug("System ID: " + str(all_systems.get(match)))
                self.ssm[match] = all_systems.get(match)


    def help_delfromssm(self):
        print "Usage: delfromssm SYSTEM1 [SYSTEM2] ..."
    
    def complete_delfromssm(self, text, line, begidx, endidx):
        return self.tab_completer(self.do_listssm('', True), text)

    def do_delfromssm(self, args):
        matches = self.filter_results(self.ssm.keys(), self.args)
        
        if len(matches) == 0:
            logging.warning("No matches found in the SSM")
            return

        for match in matches:
            logging.info("Deleting " + match + " from the SSM")
            del self.ssm[match]
            
 
    def help_listssm(self):
        print "Usage: listssm"
    
    def do_listssm(self, args, doreturn=False):
        systems = sorted(self.ssm.keys())

        if doreturn:
            return systems
        else:
            for s in systems:
                print s


    def help_clearssm(self):
        print "Usage: clearssm"
    
    def do_clearssm(self, args):
        self.ssm.clear()

###########

    def help_help(self):
        print "Usage: help COMMAND"

###########

    def help_login(self):
        print "Usage: login [USERNAME] [SERVER]"

    def do_login(self, args):
        self.session = ''
        
        if self.options.nossl:
            proto = "http"
        else:
            proto = "https"

        if len(self.args) == 2 and self.args[1]:
            server = self.args[1]
        elif self.options.server:
            server = self.options.server
        else:
            logging.error("No server specified")
            return

        server = proto + "://" + server + "/rpc/api"

        # connect to the server
        logging.debug("Connecting to " + server)
        self.client = xmlrpclib.Server(server)

        try:
            api_version = self.client.api.getVersion()
        except:
            logging.error(sys.exc_info()[1])
            self.client = None
            return

        # ensure the server is recent enough
        if api_version < self.MINIMUM_API_VERSION:
            logging.error("API (" + api_version + ") is too old (>= " \
                         + self.MINIMUM_API_VERSION + " required)")

            self.client = None
            return

        # retrieve a cached session
        if not self.options.nocache:
            if os.path.isfile(self.cache_file):
                try:
                    # read the session (format = username:session)
                    sessionfile = open(self.cache_file, "r")
                    parts = sessionfile.read().split(':')
                    sessionfile.close()
   
                    username = parts[0]
                    self.session = parts[1]
                except:
                    logging.error("Could not read " + self.cache_file)

                try:
                    logging.info("Using cached credentials from " + \
                                 self.cache_file)

                    self.client.user.listUsers(self.session)
                except:
                    logging.warning("Cached credentials are invalid")
                    self.session = ''

                    try:
                        os.remove(self.cache_file)
                    except:
                        pass
        
        # attempt to login if we don't have a valid session yet    
        if not self.session:
            if self.options.username:
                username = self.options.username
                self.options.username = None
            elif len(self.args) > 0 and self.args[0]:
                username = self.args[0]
            else:
                username = raw_input("Username: ")

            if self.options.password:
                password = self.options.password
                self.options.password = None
            else:
                password = getpass("Password: ")

            try:
                self.session = self.client.auth.login(username, 
                                                      password)
            except:
                logging.error("Invalid credentials")
                return

            # write the session to a cache
            if not self.options.nocache:
                try:
                    logging.debug("Writing session cache to " + self.cache_file) 
                    sessionfile = open(self.cache_file, "w")
                    sessionfile.write(username + ':' + self.session)
                    sessionfile.close()
                except:
                    logging.error("Could not write cache file")
 
        # disable caching of subsequent logins
        self.options.nocache = True

        logging.info("Connected to " + server + " as " + username)

###########

    def help_logout(self):
        print "Usage: logout"
        
    def do_logout(self, args):
        if self.session:
            self.client.auth.logout(self.session)
            self.session = ''
            
            try:
                os.remove(self.cache_file)
            except:
                pass
        else:
            logging.error("You're not logged in")

###########

    def help_getapi(self):
        print "Usage: getapi"


    def do_getapi(self, args):
        print self.client.api.getVersion()

###########

    def help_getsystemversion(self):
        print "Usage: getsystemversion"

    def do_getsystemversion(self, args):
        print self.client.api.systemVersion()

###########

    def help_getcertificateexpiration(self):
        print "Usage: getcertificateexpiration"

    def do_getcertificateexpiration(self, args):
        print self.client.satellite.getCertificateExpirationDate(self.session).value

###########

    def help_listentitlements(self):
        print "Usage: listentitlements"

    def do_listentitlements(self, args):
        entitlements = self.client.satellite.listEntitlements(self.session)

        print "System:"
        for e in entitlements.get('system'):
            print e.get('label') + ": " + \
                  str(e.get('used_slots')) + "/" + str(e.get('total_slots'))

        print       
 
        print "Channel:"
        for e in entitlements.get('channel'):
            print e.get('label') + ": " + \
                  str(e.get('used_slots')) + "/" + str(e.get('total_slots'))

###########

    def help_findpackages(self):
        print "Usage: findpackages QUERY"
        print "Available Fields: name, epoch, version, release, arch, " + \
              "description, summary"
        print "Example: name:kernel AND version:2.6.18 AND -description:devel" 

    def do_findpackages(self, args):
        packages = self.client.packages.search.advanced(self.session, args)
        
        for p in packages:
            print "Channel: " + p.get('provider')
            print "Package: " + self.build_package_names([p])[0]
            print

###########

    def help_listsystems(self):
        print "Usage: listsystems [PATTERN1] [PATTERN2] ..."
    
    def do_listsystems(self, args, doreturn=False, filtered=True):
        systems = self.client.system.listSystems(self.session)
        systems = [s.get('name') for s in systems]

        if filtered:
            systems = self.filter_results(systems, self.args)

        if doreturn:
            return systems
        else:
            print "\n".join(sorted(systems.keys()))

###########

    def help_getsystemdetails(self):
        print "Usage: getsystemdetails SYSTEM"

    def complete_getsystemdetails(self, text, line, begidx, endidx):
        return self.tab_completer(self.do_listsystems('', True, False), text)
 
    def do_getsystemdetails(self, args):
        if len(self.args) != 1:
            self.help_getsystemdetails()
            return

        try:
            try:
                # check if we were passed a system ID
                system_id = int(self.args[0])
    
                system = self.client.system.getName(self.session, system_id)
                last_checkin = system.get('last_checkin')
            except ValueError:
                system_id = None

            if not system_id:
                system_id = self.get_system_id(self.args[0])


            last_checkin = \
                self.client.system.getName(self.session,
                                           system_id).get('last_checkin')

            details = self.client.system.getDetails(self.session, system_id)

            registered = self.client.system.getRegistrationDate(self.session,
                                                                system_id)

            entitlements = self.client.system.getEntitlements(self.session,
                                                              system_id)

            base_channel = \
                self.client.system.getSubscribedBaseChannel(self.session,
                                                            system_id)

            child_channels = \
                self.client.system.listSubscribedChildChannels(self.session,
                                                               system_id)

            groups = self.client.system.listGroups(self.session,
                                                   system_id)

            kernel = self.client.system.getRunningKernel(self.session,
                                                         system_id)
        except xmlrpclib.Fault, err:
            logging.error(err.faultString.rsplit(': ', 1)[1])
            return 
        except:
            logging.debug(sys.exc_info()[0])
            logging.error("Could not retreive system information")
            return
       
        print "Name:          " + self.args[0] + "\n" + \
              "System ID:     " + str(system_id) + "\n" + \
              "Locked:        " + str(details.get('lock_status')) + "\n" + \
              "Registered:    " + registered.value + "\n" + \
              "Last Checkin:  " + last_checkin.value + "\n" + \
              "Kernel:        " + kernel

        print
        print "Base Channel:  " + base_channel.get('label')

        for channel in child_channels:
            print "Child Channel: " + channel.get('label')

        print

        for entitlement in entitlements:
            print "Entitlement:   " + entitlement

        print

        for group in groups:
            if group.get('subscribed') == 1:
                print "Group:         " + group.get('system_group_name')

###########

    def help_listswchannels(self):
        print "Usage: listswchannels [PATTERN1] [PATTERN2] ..."

    def do_listswchannels(self, args, doreturn=False):
        channels = self.client.channel.listAllChannels(self.session)
        channels = [c.get('label') for c in channels]

        if doreturn:
            return channels
        else:
            print "\n".join(self.filter_results(channels, self.args))
      
###########

    def help_listswchannelsystems(self):
        print "Usage: listswchannelsystems CHANNEL"

    def complete_listswchannelsystems(self, text, line, begidx, endidx):
        return self.tab_completer(self.do_listswchannels('', True), text)

    def do_listswchannelsystems(self, args):
        systems = self.client.channel.software.listSubscribedSystems(self.session,
                                                                     self.args[0])
        
        systems = [s.get('name') for s in systems]

        print "\n".join(systems)

###########

    def help_listswchannelpackages(self):
        print "Usage: listswchannelpackages CHANNEL [PATTERN1] [PATTERN2] ..."

    def complete_listswchannelpackages(self, text, line, begidx, endidx):
        # only tab complete the channel name
        if len(line.split(' ')) == 2:
            return self.tab_completer(self.do_listswchannels('', True), text)
        else:
            return []

    def do_listswchannelpackages(self, args, doreturn=False):
        packages = self.client.channel.software.listLatestPackages(self.session,
                                                                   self.args[0])

        packages = self.build_package_names(packages)

        if doreturn:
            return packages
        else:
            print "\n".join(self.filter_results(packages, self.args[1:])) 
            
###########
 
    def help_getswchanneldetails(self):
        print "Usage: getswchanneldetails CHANNEL"

    def complete_getswchanneldetails(self, text, line, begidx, endidx):
        return self.tab_completer(self.do_listswchannels('', True), text)
 
    def do_getswchanneldetails(self, args):
        if len(self.args) != 1:
            self.help_getswchanneldetails()
            return

        try:
            details = self.client.channel.software.getDetails(self.session, 
                                                              self.args[0])
        except xmlrpclib.Fault, err:
            logging.error(err.faultString.rsplit(': ', 1)[1])
            return 
       
        print "Label:           " + details.get('label') + "\n" + \
              "Name:            " + details.get('name') + "\n" + \
              "Parent:          " + details.get('parent_channel_label') + "\n" + \
              "Architecture:    " + details.get('arch_name') + "\n" + \
              "GPG Key:         " + details.get('gpg_key_id') + "\n" + \
              "GPG Fingerprint: " + details.get('gpg_key_fp') + "\n" + \
              "GPG URL:         " + details.get('gpg_key_url')

###########

# parse the options and then start the command interpreter
if __name__ == "__main__":
    optionsTable = [
        Option('-u', '--username', action='store',
               help='Use this username to connect to RHN/Satellite'),
        Option('-p', '--password', action='store',
               help='Use this password to connect to RHN/Satellite'),
        Option('--server', action='store', default="localhost", 
               help='Connect to this server (http[s]://<hostname>/APP)'),
        Option('--nocache', action='store_true',
                help="Do not create a username/password cache"),
        Option('--nossl', action='store_true',
               help="Use HTTP instead of HTTPS"),
        Option('--nohistory', action='store_true',
                help="Do not store command history in ~/.spacewalk_history"),
        Option('-d', '--debug', action='store_true',
               help="Enable debug logging"),
    ]
    
    parser = OptionParser(option_list=optionsTable)
    (options, args) = parser.parse_args()
 
    if options.debug:
        log_level = logging.DEBUG
    else:
        log_level = logging.INFO


    # setup logging
    logging.basicConfig(level=log_level, 
                        format="%(levelname)s: %(message)s")

    # setup the shell
    shell = SpacewalkShell(options)

    # start the shell
    while True:
        try:
            shell.cmdloop()
        except xmlrpclib.Fault, err:
            logging.error(err.faultString.rsplit(': ', 1)[1])
        except KeyboardInterrupt:
            print

# vim:ts=4:expandtab:
