#
# Copyright (c) 2008 Red Hat, Inc.
#
# This software is licensed to you under the GNU General Public License,
# version 2 (GPLv2). There is NO WARRANTY for this software, express or
# implied, including the implied warranties of MERCHANTABILITY or FITNESS
# FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2
# along with this software; if not, see
# http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.
# 
# Red Hat trademarks are not licensed under GPLv2. No permission is
# granted to use or replicate Red Hat trademarks that are incorporated
# in this software or its documentation. 
#

package RHN::ErrataMailer;
use strict;

use Params::Validate;

use RHN::DB;
use RHN::Errata;
use RHN::Postal;

sub new {
  my $class = shift;
  my %params = validate(@_, { -errata_id => 1, -org_id => 1 });

  my $self = bless { users => {}, servers => {} }, $class;
  $self->{errata_id} = $params{-errata_id};
  $self->{org_id} = $params{-org_id};

  return $self;
}

sub prepare_work_queue {
  my $self = shift;
  my %params = validate(@_, { -dbh => 1 });
  my $dbh = $params{-dbh};
  my $errata_id = $self->{errata_id};

  my @query_params = (errata_id => $errata_id, org_id => $self->{org_id});
  my $query = <<"  EOS";
  INSERT INTO rhnPaidErrataTempCache
    (user_id, server_id, errata_id)
  SELECT DISTINCT user_id, server_id, :errata_id
    FROM rhnPrivateErrataMail
   WHERE errata_id = :errata_id
     AND org_id = :org_id
  EOS

  my $sth = $dbh->prepare($query);
  $sth->execute_h(@query_params);
}

sub prepare_users {
  my $self = shift;
  my %params = validate(@_, { -dbh => 1 });
  my $dbh = $params{-dbh};

  my $user_sth = $dbh->prepare(<<"  EOS");
  SELECT WC.id, WC.org_id, WC.login, WUPI.email
    FROM web_user_personal_info WUPI,
         web_contact WC,
         rhnPaidErrataTempCache PETC
   WHERE WC.id = PETC.user_id
     AND WUPI.web_user_id = WC.id
  EOS
  $user_sth->execute;
  while (my $user = $user_sth->fetchrow_hashref_copy) {
    $self->{users}->{$user->{ID}} = $user;
  }
}

sub prepare_systems {
  my $self = shift;
  my %params = validate(@_, { -dbh => 1 });
  my $dbh = $params{-dbh};

  my $system_sth = $dbh->prepare(<<"  EOS");
  SELECT S.id, S.name, C.name base_channel
    FROM rhnChannel C,
         rhnServerChannel SC,
         rhnServer S,
         rhnServerArch SA,
         rhnPaidErrataTempCache PETC
   WHERE S.server_arch_id = SA.id
     AND S.id = PETC.server_id
     AND S.id = SC.server_id
     AND SC.channel_id = C.id
     AND C.parent_channel IS NULL
  EOS
  $system_sth->execute;
  while (my $system = $system_sth->fetchrow_hashref_copy) {
    $self->{servers}->{$system->{ID}} = $system;
  }
}

sub prepare_batch {
  my $self = shift;
  my %params = validate(@_, { -dbh => 1 });
  my $dbh = $params{-dbh};

  my $batch_sth = $dbh->prepare(<<"  EOS");
  SELECT user_id, server_id
    FROM rhnPaidErrataTempCache PETC
  EOS
  $batch_sth->execute;
  while (my ($user_id, $server_id) = $batch_sth->fetchrow) {
    push @{$self->{batch}->{$user_id}}, $server_id;
  }
}

sub prepare_errata {
  my $self = shift;

  my $e = RHN::Errata->lookup(-id => $self->{errata_id});
  my $errata_subst =
    {
     'errata-id' => $e->id,
     'errata-advisory' => $e->advisory,
     'errata-advisory-type' => $e->advisory_type,
     'errata-topic' => $e->topic,
     'errata-synopsis' => $e->synopsis,
     'errata-description' => $e->description,
     'errata-notes' => $e->notes,
     'errata-references' => $e->refers_to,
    };

  $self->{errata} = $e;
  $self->{errata_substitutions} = $errata_subst;
}

sub prepare_postal {
  my $self = shift;

  my $letter = new RHN::Postal;
  my $filename = "errata_mail/paid_errata_notice.xml";
  $letter->template($filename);

  $self->{letter} = $letter;
  $letter->set_tag($_, $self->{errata_substitutions}->{$_}) for keys %{$self->{errata_substitutions}};
}

sub send_user_email {
  my $self = shift;
  my %params = validate(@_, { -user_id => 1 });
  my $user_id = $params{-user_id};

  my $letter = $self->{letter};
  $letter->set_tag("login" => $self->{users}->{$user_id}->{LOGIN});
  $letter->set_tag("email-address" => $self->{users}->{$user_id}->{EMAIL});

  my @systems = sort { $self->{servers}->{$a}->{NAME} cmp $self->{servers}->{$b}->{NAME} } @{$self->{batch}->{$user_id}};
  $letter->set_tag("system-count" => scalar @systems);
  if (@systems > 1) {
    $letter->set_tag("system-count-verb", "are");
    $letter->set_tag("system-count-plural", "s");
  }
  else {
    $letter->set_tag("system-count-verb", "is");
    $letter->set_tag("system-count-plural", "");
  }

  my $affected_list_string;
  for my $system (@systems) {
    $affected_list_string .=
      sprintf("%-32s%s\n", $self->{servers}->{$system}->{NAME}, $self->{servers}->{$system}->{BASE_CHANNEL});
  }

  $letter->set_tag("system-affected-list" => $affected_list_string);
  $letter->render;
  $letter->to($self->{users}->{$user_id}->{EMAIL});
  $letter->set_header("X-RHN-Info" => "Autogenerated mail for $self->{users}->{$user_id}->{LOGIN}");
  $letter->set_header("Precedence" => "first-class");
  $letter->set_header("Errors-To" => sprintf('rhn-bounce+%d-%d@rhn.redhat.com',
					     $user_id,
					     $self->{users}->{$user_id}->{ORG_ID}));
  $letter->send;
}

sub prepare_job {
  my $self = shift;
  my %params = validate(@_, { -dbh => 1 });
  my $dbh = $params{-dbh};

  $self->prepare_errata();
  $self->prepare_work_queue(-dbh => $dbh);
  $self->prepare_users(-dbh => $dbh);
  $self->prepare_systems(-dbh => $dbh);
  $self->prepare_batch(-dbh => $dbh);
  $self->prepare_postal();
}

sub send_all_emails {
  my $self = shift;
  use Time::HiRes qw/time/;
  my $dbh = RHN::DB->connect;
  $self->prepare_job(-dbh => $dbh);

  for my $user_id (sort keys %{$self->{batch}}) {
    $self->send_user_email(-user_id => $user_id);
  }

  $dbh->do("DELETE FROM rhnPaidErrataTempCache");
}

1;
