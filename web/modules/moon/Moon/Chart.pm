#
# Copyright (c) 2008 Red Hat, Inc.
#
# This software is licensed to you under the GNU General Public License,
# version 2 (GPLv2). There is NO WARRANTY for this software, express or
# implied, including the implied warranties of MERCHANTABILITY or FITNESS
# FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2
# along with this software; if not, see
# http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.
# 
# Red Hat trademarks are not licensed under GPLv2. No permission is
# granted to use or replicate Red Hat trademarks that are incorporated
# in this software or its documentation. 
#

package Moon::Chart;

use strict;

use Data::Dumper;

use Moon::Image;
use Moon::Chart::TimeAxes;
use Moon::Dataset::Coordinate;

# args:  (width, height) of final image
sub new {
  my $class = shift;
  my $self = bless { }, $class;
  my ($size_x, $size_y) = @_;

  die "Must provide width, height of final png image to Moon::Chart constructor"
    unless (defined $size_x and defined $size_y);

  $self->{__image__} = new Moon::Image($size_x, $size_y);
  $self->{__datasets__} = {};

  # defaults
  $self->{__graph_stencil_min__} = [0.1 * $size_x, 0.1 * $size_y];
  $self->{__graph_stencil_max__} = [0.9 * $size_x, 0.9 * $size_y];

  #$self->graph_stencil_min(0.1 * $size_x, 0.1 * $size_y);
  #$self->graph_stencil_max(0.9 * $size_x, 0.9 * $size_y);

  return $self;
}

sub add_dataset {
  my $self = shift;
  my $data_label = shift;
  my $dataset = shift;

  die "duplicate datasets??" if ($self->{__datasets__}->{$data_label});

  $self->{__datasets__}->{$data_label} = $dataset;
}

sub get_datasets {
  my $self = shift;

  return $self->{__datasets__};
}

sub set_axes {
  my $self = shift;
  my $axes = shift;

  $self->{__axes__} = $axes;
}

# access to the image
sub image {
  my $self = shift;
  my $new_image = shift;

  if ($new_image) {
    $self->{__image__} = $new_image;
  }
  else {
    return $self->{__image__};
  }
}

# accessors for the stencil area in chart cs (0->1, 0->1)
sub graph_stencil_min {
  my $self = shift;

  if (@_) {
    my ($size_x, $size_y) = $self->{__image__}->get_size();
    my ($min_x, $min_y) = @_;
    $self->{__graph_stencil_min__} = [$min_x * $size_x, $min_y * $size_y];
  }
  else {
    return $self->{__graph_stencil_min__};
  }
}

sub graph_stencil_max {
  my $self = shift;
  if (@_) {
    my ($size_x, $size_y) = $self->{__image__}->get_size();
    my ($max_x, $max_y) = @_;
    $self->{__graph_stencil_max__} = [$max_x * $size_x, $max_y * $size_y];
  }
  else {
    return $self->{__graph_stencil_max__};
  }
}

sub _S {
  my $self = shift;
  my $term = shift;

  my ($data_min, $data_max) = $self->{__axes__}->get_bounds();

  return ($self->{__graph_stencil_max__}->[$term] - $self->{__graph_stencil_min__}->[$term])
    / ($data_max->[$term] - $data_min->[$term]);
}

sub _image_to_data_fn {
  my $self = shift;

  my $Sx = $self->_S(0);
  my $Sy = $self->_S(1);

  my @image_size = $self->{__image__}->get_size();

  my ($data_min, $data_max) = $self->{__axes__}->get_bounds();

#           int( ($x - $self->{__graph_min__}->[0]) / ($Sx) + $data_min[0] ),
#           int($image_size[1] - ( ($y - $self->{__graph_min__}->[1]) / ($Sy) + $data_min[1] ))

  return sub {
    my ($x, $y) = @_;
    return (
	    int( ($x - $self->{__graph_stencil_min__}->[0]) / ($Sx) + $data_min->[0]),
	    int($image_size[1] - ( ($y - $self->{__graph_stencil_min__}->[1]) / ($Sy) + $data_min->[1]))
	   );
  };

}

sub _data_to_image_fn {
  my $self = shift;

  my $Sx = $self->_S(0);
  my $Sy = $self->_S(1);

  my @image_size = $self->{__image__}->get_size();

  my ($data_min, $data_max) = $self->{__axes__}->get_bounds();


#           int($Sx * ($x - $data_min[0]) + $self->{__graph_min__}->[0]),
#           int($image_size[1] - ($Sy * ($y - $data_min[1]) + $self->{__graph_min__}->[1]))

  return sub {
    my ($x, $y) = @_;
    return (
	    int($Sx * ($x - $data_min->[0]) + $self->{__graph_stencil_min__}->[0]),
	    int($image_size[1] - ($Sy * ($y - $data_min->[1]) + $self->{__graph_stencil_min__}->[1]))
	   );
  };
}

sub render_to_file {
  my $self = shift;
  my $filename = shift;

  # figure out the cumulative mins/maxes of the datasets?  Inefficient, and might belong elsewhere...
  my @mins_maxes;

  foreach my $datalabel (keys %{$self->{__datasets__}}) {
    my $dataset = $self->{__datasets__}->{$datalabel};
    push @mins_maxes, ([ $dataset->min_x(), $dataset->min_y() ], [ $dataset->max_x(), $dataset->max_y() ]);
  }

  my $min_max_ds = new Moon::Dataset::Coordinate();
  $min_max_ds->coords(\@mins_maxes);

  # if we don't already have the axes, make 'em from the dataset metadata
  if (!defined $self->{__axes__}) {
    $self->{__axes__} = new Moon::Chart::TimeAxes([ $min_max_ds->min_x(), $min_max_ds->min_y() ],
						  [ $min_max_ds->max_x(), $min_max_ds->max_y() ]
						 );
  }

  # either set manually on the axes, or generated by the axes from the data
  my ($data_min, $data_max) = $self->{__axes__}->get_bounds();


  my @image_size = $self->{__image__}->get_size();

  # directly map data pts to image space:  (0,0) -> (300, 300) in pixels
  #  x' == (Sx)(x) + tx, Sx == some scale, x == xcoord from dataset, tx == some transformation, x' == new xcoord
  #  y' == (Sy)(y) + ty, Sy == some scale, y == ycoord from dataset, ty == some transformation, y' == new ycoord

  my ($stencil_min_x, $stencil_min_y) = ($self->{__graph_stencil_min__}->[0], $self->{__graph_stencil_min__}->[1]);
  my ($stencil_max_x, $stencil_max_y) = ($self->{__graph_stencil_max__}->[0], $self->{__graph_stencil_max__}->[1]);

  my $map_data_to_image_cs = $self->_data_to_image_fn();
  my $map_image_to_data_cs = $self->_image_to_data_fn();


  # TODO:  wrap this ugliness and cheating in Moon::Image...
  my $watermark = Moon::Image->load_from_file("/var/www/html/img/rhn-logo-screened.png");

#   foreach my $w_color_index (0 .. $watermark->{__image__}->colorsTotal()) {
#     $self->{__image__}->add_color($watermark->get_rgb($w_color_index));
#   }

  # 1st color added seems to be the default background color...
  my $white = $self->image()->get_color(255, 255, 255);
  my $black = $self->image()->get_color(0, 0, 0);
  my $grey = $self->image()->get_color(167, 167, 167);

  my @dataset_colors;

  my @colors = ( [ 0, 0, 255 ], [ 255, 0, 0 ], [ 0, 255, 0 ],
		 [ 255, 255, 0 ], [ 255, 0, 255 ], [ 0, 255, 255 ],
		 [ 0, 153, 255 ], [ 0, 255, 153 ], [ 255, 0, 153 ],
		 [ 255, 153, 0 ], [ 153, 255, 0 ], [ 153, 0, 255 ],
		 [ 255, 255, 255 ], [ 255, 127, 255 ], [ 127, 255, 127 ],
		 [ 127, 127, 255 ], [ 255, 127, 255 ], [ 63, 63, 63 ],);


  foreach my $color (@colors) {
    unshift @dataset_colors, $self->image()->get_color(@{$color});
  }

  # CRAP.  GD::filledRectangle is broken, meethinks.

  $self->image()->draw_rectangle($stencil_min_x + 3, $image_size[1] - $stencil_min_y + 3,
				 $stencil_max_x + 3, $image_size[1] - $stencil_max_y + 3,
				 $grey);

  $self->image()->{__image__}->fillToBorder($stencil_min_x + ($stencil_max_x - $stencil_min_x)/2,
					    $image_size[1] - ($stencil_min_y + ($stencil_max_y - $stencil_min_y)/2),
					    $grey, $grey);


  $self->image()->draw_rectangle($stencil_min_x, $image_size[1] - $stencil_min_y,
				 $stencil_max_x, $image_size[1] - $stencil_max_y,
				 $black);

  $self->image()->{__image__}->fillToBorder($stencil_min_x + ($stencil_max_x - $stencil_min_x)/2,
					    $image_size[1] - ($stencil_min_y + ($stencil_max_y - $stencil_min_y)/2),
					    $black, $white);

  my @watermark_size = $watermark->get_size();
  my $watermark_x = $stencil_min_x + ($stencil_max_x - $stencil_min_x)/2 - $watermark_size[0]/2;
  my $watermark_y = $image_size[1] - ($stencil_min_y + ($stencil_max_y - $stencil_min_y)/2) - $watermark_size[1]/2;

  $self->{__axes__}->_draw($self->image(), $map_data_to_image_cs,
			   $stencil_max_x - $stencil_min_x,
			   $stencil_max_y - $stencil_min_y);


  my $current_color;

  my $font_size = $self->{__image__}->get_font_size_normal();

  my $dataset_counter = 1;

  my @labels = sort keys %{$self->{__datasets__}};
  my $longest = 0; #the length of the longest *odd numbered* label - for the legend

  foreach my $datalabel (@labels) {
    if ($dataset_counter % 2 and length $datalabel > $longest) {
      $longest = length $datalabel;
    }
    $dataset_counter++;
  }

  $dataset_counter = 1;

  foreach my $datalabel (@labels) {

    if (@dataset_colors) {
      $current_color = pop @dataset_colors;
    }
    else {
      die "ran out of colors!";
    }

    my $dataset = $self->{__datasets__}->{$datalabel};

    # draw MRTG'ish graph, using pixel cs
    my $last_pt;

    my $ds_draw_min_x;
    my ($ds_pixel_min_x, $foo) = $map_data_to_image_cs->($dataset->min_x(), 0);

    $ds_draw_min_x = $ds_pixel_min_x > $stencil_min_x ? $ds_pixel_min_x : $stencil_min_x;

    foreach my $pixel_x ($ds_draw_min_x .. $stencil_max_x) {

      my ($x, $foo) = $map_image_to_data_cs->($pixel_x, 0);

      my $y;

      eval {
	$y = $dataset->value_at($x);
      };
      if ($@) {
	if ($@ =~ m/outside of bounds/) {
	  # what to do when we don't have data?
	  #warn "data point out of bounds...";
	  next;
	}
	else {
	  die $@;
	}
      }

      if (defined $y) {

	if ($y > $data_max->[1]) {
	  $y = $data_max->[1];
	}
	elsif ($y < $data_min->[1]) {
	  $y = $data_min->[1];
	}

	my ($throwaway, $pixel_y) = $map_data_to_image_cs->($x, $y);

	if ($last_pt) {
	  my @ics_last = ($last_pt->[0], $last_pt->[1]);
	  my @ics_current = ($pixel_x,  $pixel_y);

	  $self->{__image__}->draw_line(@ics_last, @ics_current, $current_color);
	}

	$last_pt = [ $pixel_x, $pixel_y ];
      }
      else {
	$last_pt = 0;
      }

    }

    my ($legend_x, $legend_y);

    if ($dataset_counter % 2) {
      $legend_x = 60;
      $legend_y = ($image_size[1] - $stencil_min_y) + int($font_size->[1] * .8) + $dataset_counter * (int($font_size->[1] * .6));
                  #bottom of graph                  + room for time/date        + the row number   * height of font
    } else {
      $legend_x = $longest * $font_size->[0] + 85;
      $legend_y = ($image_size[1] - $stencil_min_y) + int($font_size->[1] * .8) + ($dataset_counter - 1) * (int($font_size->[1] * .6));
                  #bottom of graph                  + room for time/date        +  the row number        *  height of font
    }

    $self->{__image__}->draw_text($legend_x, $legend_y, $datalabel, $black);
    $self->{__image__}->draw_line($legend_x - 5, $legend_y + $font_size->[1]/2, $legend_x - 15,
				  $legend_y + $font_size->[1]/2, $current_color);

    $dataset_counter++;
  }

  # draw border last...
  $self->image()->draw_rectangle($stencil_min_x, $image_size[1] - $stencil_min_y,
				 $stencil_max_x, $image_size[1] - $stencil_max_y,
				 $black);

  $self->image()->save($filename);
}

my $VERSION = '0.01';

1;
__END__
# Below is stub documentation for your module. You better edit it!

=head1 NAME

Moon::Chart - Implementation of a Chart class for use with RHN Monitoring.

=head1 SYNOPSIS

  use Moon::Chart;

=head1 DESCRIPTION

Uses Moon::Dataset and Moon::Image to draw a graph from a set of data

=head2 EXPORT

No.

=head1 AUTHOR

Spacewalk Team <rhn-feedback@redhat.com>

=head1 SEE ALSO

rhn.redhat.com

L<perl>.

=cut
