#!/usr/bin/perl

use strict;
use LWP::UserAgent;
use IO::File;
use Getopt::Long;



# Configuration
my $DLDIR   = '/var/tmp';
my $BASEURL = 'https://smon.nocpulse.com/depot/';
my $VERBOSE = 0;


my $dldir   = $DLDIR;
my $baseurl = $BASEURL;
my $verbose = $VERBOSE;
my $wait    = 0;
my $verify  = 0;
&GetOptions(
  'dldir=s'      => \$dldir,
  'baseurl=s'    => \$baseurl,
  'wait=s'       => \$wait,
  'verbose+'     => \$verbose,
  'verify+'      => \$verify,
  'help+'        => sub {die &usage()},
);


# Make STDOUT unbuffered so we can see what's happening
select((select(STDOUT), $|=1)[0]);


# Set up file records
my @filerecs;
foreach my $file (@ARGV) {
  push(@filerecs, {
    basename => $file,
    dl_path  => "$dldir/$file",
    dl_tmp   => "$dldir/$file.TMP",
    url      => "$baseurl/$file",
    range_s  => 0,
    range_e  => 0,
    fh       => IO::File->new(),
    fsize    => 0,
  });
}


##############################################################################
###############################     Main      ################################
##############################################################################

# Create the download directory if it doesn't exist
&mkdirhier($dldir, 0755) unless (-d $dldir);


# Create the user agent
my $ua = LWP::UserAgent->new();


# Verify sufficient disk space in the download directory
my $nfiles = &verify_disk_space($ua, $dldir, \@filerecs);
die "$@\n" unless (defined($nfiles));

if ($nfiles == 0) {
  # All files have already been downloaded
  print "All files have already been successfully downloaded\n";
  exit 0;
}

if ($verify) {
  print "Verification complete\n";
  exit 0;
}


# If requested, delay a bounded random interval before starting
if ($wait) {
  my($min, $max) = split(/:/, $wait);

  # If only one argument is provided, treat it as the max
  unless ($max) {
    $max = $min;
    $min = 0;
  }

  my $sleepmins = $min + rand($max - $min);

  if ($verbose) {
    print "Current time:           ", scalar(localtime(time)), "\n";
    print "Download will begin at: ", 
      scalar(localtime(time + $sleepmins * 60)), "\n";
  }
  sleep $sleepmins * 60;

}


# Start the downloads
foreach my $rec (@filerecs) {

  my $file = $rec->{'basename'};
  my $req  = HTTP::Request->new(GET => $rec->{'url'});

  # Is this a new download or a resumption?
  my $resume = 0;
  if (-f $rec->{'dl_path'}) {

    print "Skipping $file (already in $dldir)\n" if ($verbose);
    next;

  } elsif (-f $rec->{'dl_tmp'}) {

    print "Resuming $file download\n" if ($verbose);
    $rec->{'fh'}->open(">> $rec->{'dl_tmp'}") 
                         or die "Couldn't append to $rec->{'dl_tmp'}: $!";
    my $start = (stat($rec->{'dl_tmp'}))[7];

    # Add a Range: header if we 
    $req->header('Range', "bytes=$start-$rec->{'fsize'}");

  } else {

    print "Downloading $file\n" if ($verbose);
    $rec->{'fh'}->open("> $rec->{'dl_tmp'}") 
                         or die "Couldn't create $rec->{'dl_tmp'}: $!";

  }


  my $cb  = sub {
    my($data, $response, $protocol) = @_;

    # Save the data
    $rec->{'fh'}->print($data);
    $rec->{'fh'}->flush();

  };

  my $res = $ua->request($req, $cb);

  if (my $msg = $res->header('x-died')) {

    die $msg;

  } else {

    rename($rec->{'dl_tmp'}, $rec->{'dl_path'}) 
      or die "Couldn't rename $rec->{'dl_tmp'} -> $rec->{'dl_path'}: $!";

    print "$file successfully downloaded\n";

  }


}


##############################################################################
###############################  Subroutines  ################################
##############################################################################


#######################
sub verify_disk_space {
#######################
  my($ua, $dldir, $filerecs) = @_;
  my $nfiles = 0;

  # Get the amount of disk space left on the download device
  my $free = &df($dldir);


  # Get file sizes for each file
  my $totalsize = 0;
  foreach my $rec (@$filerecs) {

    my $file = $rec->{'basename'};

    if (-f $rec->{'dl_path'}) {
      print "File $file is already complete\n" if ($verbose);
      next;
    }

    $nfiles++;

    $rec->{'fsize'} = &get_file_size($ua, $rec->{'url'});
    print "File $file size: $rec->{'fsize'} bytes\n" if ($verbose);

    if (-f $rec->{'dl_tmp'}) {

      my $downloaded = (stat($rec->{'dl_tmp'}))[7];
      $totalsize += $rec->{'fsize'} - $downloaded;
      print "\t$downloaded bytes already downloaded\n" if ($verbose);

    } else {

      $totalsize += $rec->{'fsize'};

    }

  }

  print "Total required:   $totalsize bytes\n" if ($verbose);
  print "Total available:  $free bytes\n" if ($verbose);
  if ($totalsize > $free) {
    my $deficit = $totalsize - $free;
    $@ = "Not enough space in $dldir ($deficit bytes short)\n";
    return undef;
  } else {
    print "There is sufficient space for the download\n" if ($verbose);
  }

  return $nfiles;
}


########
sub df {
########
  my $fs = shift;
  my $output = (split(/\n/, `df $fs`, 2))[1];
  my($avail) = (split(/\s+/, $output, 5))[3];

  return $avail * 1024;
  
}




###################
sub get_file_size {
###################
  my($ua, $url) = @_;

  # Get the file size.

  my $req = HTTP::Request->new(HEAD => $url);

  my $res = $ua->request($req);

  if ($res->is_success) {
    my $size = $res->headers->header('content-length');
    return($size);
  } else {
    die "Couldn't retrieve file size for $url:  " . $res->status_line;
  }

}



###############
sub mkdirhier {
###############
  my $path = shift;
  my $mode = shift;

  my $curpath = '';

  $path = "./$path" unless ($path =~ /^\//);

  my @pathname_components = split("/", $path);

  while (@pathname_components) {

    $curpath .= shift(@pathname_components) . "/";

    if (! -d $curpath) {

      my $rc = mkdir($curpath, $mode);

      if( not $rc and not ( $! =~ /File exists/ ) ) {

        die "Couldn't create $curpath: $!";

      }

    }

  }

  return 1;

}


###########
sub usage {
###########

  return qq{
    Usage:
      $0 [<options>] <files>
    Options:
      --dldir=<DIR>      - download into <DIR> (will be created)
      --baseurl=<URL>    - base URL for files
      --wait=<MIN>:<MAX> - wait minimum <MIN>, max <MAX> minutes first
      --verbose          - turn on verbose mode
      --help             - show this message
    Defaults:
      verbose: $VERBOSE
      dldir:   $DLDIR
      baseurl: $BASEURL
      wait:    none
    \n};
}


__END__

=head1 NAME

download - Perl script for resumable downloads with built-in delay

=head1 SYNOPSIS

    download [<options>] <files>

    Options:
      --dldir=<DIR>      - download into <DIR> (will be created)
      --baseurl=<URL>    - base URL for files
      --wait=<MIN>:<MAX> - wait minimum <MIN>, max <MAX> minutes first
      --verbose          - turn on verbose mode
      --help             - show this message

=head1 DESCRIPTION

B<download> is a script for downloading files from a central 
repository.  It is able to resume interrupted downloads, and delay
a random interval before the start of the interval.  It can also
merely verify that the files are reachable and enough space is
available on the filesystem for the download to succeed.

=head1 OPTIONS

=over 2

=item --dldir=<DIR>

Specifies the directory into which you wish to download files.

=item --baseurl=<URL>

Specifies the base URL for the files you want to download.

=item --wait=<MIN>:<MAX>

Waits a random amount of time between <MIN> and <MAX> minutes
before beginning the download.  If only one number is supplied,
it is treated as the <MAX> with a <MIN> of zero.  Note that
--wait does B<not> cause a delay before verification, so the
download will fail immediately if the files are not available
or there is insufficient space on the filesystem.

=item --verbose

Turn on verbose mode.  Without it, you only get error messages
or a single success message per file.

=item --help

Show syntax.  Also shows default values.

=back

=head1 AUTHOR

Dave Faraldo E<lt>dfaraldo@redhat.comE<gt>

=head1 DATE

Last modified: $Date: 2003-09-25 23:56:36 $

=cut

