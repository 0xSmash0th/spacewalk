#!/usr/bin/perl

use Getopt::Long;

################## SUBS
sub help
{
	return qq{
		Usage: $0 <options>
		Required parameters:
		--command="blah blah"
		--max-delay="xMinutes"
		--logfile="/path/To.Log"
		--help			- show this message
		\n
	}
}




################## MAINLINE 
my ($maxDelay,$logFile,$help,$command);

$|=1;

&GetOptions (
	'max-delay=i' => \$maxDelay,
	'command=s' => \$command,
	'logfile=s' => \$logFile,
	'help+' => \$help
);

die &help."\n" if ($help);
die &help."\n" if (! $maxDelay);
die &help."\n" if (! $command);
die &help."\n" if (! $logFile);

my $delay = rand($maxDelay*60);

if (fork()) {
	my ($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst) = localtime(time() + $delay);
	print "Delaying execution of '$command'\n";
	printf("Execution will occur at %02d:%02d:%02d on %d/%d/%d\n",$hour,$min,$sec,$mon+1,$mday,(1900+$year));
} else {
	sleep($delay);
	my $date_executed = time();
	my $STDOUT = `($command) 2>&1`;
	my $status = $?;
	my $execution_time = time() - $date_executed;
	my ($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst) = localtime($date_executed);
	open(FILE,">$logFile");
	print FILE "-" x 60;
	print FILE "\nCOMMAND: $command\n";
	print FILE sprintf("EXECUTED: %02d:%02d:%02d on %d/%d/%d\n",$hour,$min,$sec,$mon+1,$mday,(1900+$year));
	print FILE "DURATION: $execution_time\n";
	print FILE "EXIT: $status\n";
	print FILE "STDOUT FOLLOWS:\n";
	print FILE "$STDOUT\n";
	close(FILE);
}
