.\" Automatically generated by Pod::Man version 1.15
.\" Fri Aug 22 01:12:55 2003
.\"
.\" Standard preamble:
.\" ======================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Ip \" List item
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R

.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used
.\" to do unbreakable dashes and therefore won't be available.  \*(C` and
.\" \*(C' expand to `' in nroff, nothing in troff, for use with C<>
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr
.\" for titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and
.\" index entries marked with X<> in POD.  Of course, you'll have to process
.\" the output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it
.\" makes way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.bd B 3
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ======================================================================
.\"
.IX Title "SSL 3"
.TH SSL 3 "perl v5.6.1" "2003-06-26" "User Contributed Perl Documentation"
.UC
.SH "NAME"
\&\s-1IO:\s0:Socket::SSL \*(-- Nearly transparent \s-1SSL\s0 encapsulation for \s-1IO:\s0:Socket::INET.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use IO::Socket::SSL;
.Ve
.Vb 1
\&    my $client = new IO::Socket::SSL("www.example.com:https");
.Ve
.Vb 8
\&    if (defined $client) {
\&        print $client "GET / HTTP/1.0\er\en\er\en";
\&        print <$client>;
\&        close $client;
\&    } else {
\&        warn "I encountered a problem: ",
\&          &IO::Socket::SSL::errstr();
\&    }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module is a true drop-in replacement for \s-1IO:\s0:Socket::INET that uses
\&\s-1SSL\s0 to encrypt data before it is transferred to a remote server or
client.  \s-1IO:\s0:Socket::SSL supports all the extra features that one needs
to write a full-featured \s-1SSL\s0 client or server application: multiple \s-1SSL\s0 contexts,
cipher selection, certificate verification, and \s-1SSL\s0 version selection.  As an
extra bonus, it works perfectly with mod_perl.
.PP
If you have never used \s-1SSL\s0 before, you should read the appendix labelled 'Using \s-1SSL\s0'
before attempting to use this module.
.PP
If you have used this module before, read on, as versions 0.93 and above
have several changes from the previous \s-1IO:\s0:Socket::SSL versions (especially
see the note about return values).
.SH "METHODS"
.IX Header "METHODS"
\&\s-1IO:\s0:Socket::SSL inherits its methods from \s-1IO:\s0:Socket::INET, overriding them
as necessary.  If there is an \s-1SSL\s0 error, the method or operation will return an
empty list (false in all contexts).  The methods that have changed from the 
perspective of the user are re-documented here:
.Ip "\fBnew(...)\fR" 4
.IX Item "new(...)"
Creates a new \s-1IO:\s0:Socket::SSL object.  You may use all the friendly options
that came bundled with \s-1IO:\s0:Socket::INET, plus (optionally) the ones that follow:
.RS 4
.Ip "SSL_version" 2
.IX Item "SSL_version"
Sets the version of the \s-1SSL\s0 protocol used to transmit data.  The default is SSLv2/3,
which auto-negotiates between SSLv2 and SSLv3.  You may specify 'SSLv2', 'SSLv3', or
\&'TLSv1' (case-insensitive) if you do not want this behavior.
.Ip "SSL_cipher_list" 2
.IX Item "SSL_cipher_list"
If you do not care for the default list of ciphers ('\s-1ALL:\s0!LOW:!EXP'), then look in
the OpenSSL documentation (http://www.openssl.org/docs/apps/ciphers.html#CIPHER_STRINGS),
and specify a different set with this option.
.Ip "SSL_use_cert" 2
.IX Item "SSL_use_cert"
If this is set, it forces \s-1IO:\s0:Socket::SSL to use a certificate and key, even if
you are setting up an \s-1SSL\s0 client.  If this is set to 0 (the default), then you will
only need a certificate and key if you are setting up a server.
.Ip "SSL_key_file" 2
.IX Item "SSL_key_file"
If your \s-1RSA\s0 private key is not in default place (\fIcerts/server-key.pem\fR for servers,
\&\fIcerts/client-key.pem\fR for clients), then this is the option that you would use to
specify a different location.  Keys should be \s-1PEM\s0 formatted, and if they are
encrypted, you will be prompted to enter a password before the socket is formed
(unless you specified the SSL_passwd_cb option).
.Ip "SSL_cert_file" 2
.IX Item "SSL_cert_file"
If your \s-1SSL\s0 certificate is not in the default place (\fIcerts/server-cert.pem\fR for servers,
\&\fIcerts/client-cert.pem\fR for clients), then you should use this option to specify the 
location of your certificate.  Note that a key and certificate are only required for an
\&\s-1SSL\s0 server, so you do not need to bother with these trifling options should you be
setting up an unauthenticated client.
.Ip "SSL_passwd_cb" 2
.IX Item "SSL_passwd_cb"
If your private key is encrypted, you might not want the default password prompt from
Net::SSLeay.  This option takes a reference to a subroutine that should return the
password required to decrypt your private key.  Note that Net::SSLeay >= 1.16 is
required for this to work.
.Ip "SSL_ca_file" 2
.IX Item "SSL_ca_file"
If you want to verify that the peer certificate has been signed by a reputable
certificate authority, then you should use this option to locate the file
containing the certificate\&(s) of the reputable certificate authorities if it is
not already in the file \fIcerts/my-ca.pem\fR.
.Ip "SSL_ca_path" 2
.IX Item "SSL_ca_path"
If you are unusually friendly with the OpenSSL documentation, you might have set
yourself up a directory containing several trusted certificates as separate files
as well as an index of the certificates.  If you want to use that directory for
validation purposes, and that directory is not \fIca/\fR, then use this option to
point \s-1IO:\s0:Socket::SSL to the right place to look.
.Ip "SSL_verify_mode" 2
.IX Item "SSL_verify_mode"
This option sets the verification mode for the peer certificate.  The default
(0x00) does no authentication.  You may combine 0x01 (verify peer), 0x02 (fail
verification if no peer certificate exists; ignored for clients), and 0x04 
(verify client once) to change the default.
.Ip "SSL_verify_callback" 2
.IX Item "SSL_verify_callback"
If you want to verify certificates yourself, you can pass a sub reference along
with this parameter to do so.  When the callback is called, it will be passed:
1) a true/false value that indicates what OpenSSL thinks of the certificate,
2) a C-style memory address of the certificate store,
3) a string containing the certificate's issuer attributes and owner attributes, and
4) a string containing any errors encountered (0 if no errors).
The function should return 1 or 0, depending on whether it thinks the certificate
is valid or invalid.  The default is to let OpenSSL do all of the busy work.
.Ip "SSL_check_crl" 2
.IX Item "SSL_check_crl"
If you want to verify that the peer certificate has not been revoked by the
signing authority, set this value to true.  OpenSSL will search for the \s-1CRL\s0
in your SSL_ca_path.  See the Net::SSLeay documentation for more details.
Note that this functionality appears to be broken with OpenSSL < 0.9.7b,
so its use with lower versions will result in an error.
.Ip "SSL_reuse_ctx" 2
.IX Item "SSL_reuse_ctx"
If you have already set the above options (SSL_use_cert through SSL_verify_mode;
this does not include SSL_cipher_list yet) for a previous instance of
\&\s-1IO:\s0:Socket::SSL, then you can reuse the \s-1SSL\s0 context of that instance by passing
it as the value for the SSL_reuse_ctx parameter.  If you pass any context-related options,
they will be ignored.  Note that, contrary to versions of \s-1IO:\s0:Socket::SSL below v0.90,
a global \s-1SSL\s0 context will not be implicitly used.
.Ip "SSL_error_trap" 2
.IX Item "SSL_error_trap"
When using the \fIaccept()\fR or \fIconnect()\fR methods, it may be the case that the
actual socket connection works by the \s-1SSL\s0 negotiation fails, as in the case of
an \s-1HTTP\s0 client connecting to an \s-1HTTPS\s0 server.  Passing a subroutine ref attached
to this parameter allows you to gain control of this socket instead of having it
be forcibly closed.  The subroutine, if called, will be passed two parameters: 
a reference to the socket on which the \s-1SSL\s0 negotiation failed and and the full
text of the error message.
.RE
.RS 4
.RE
.Ip "\fBclose(...)\fR" 4
.IX Item "close(...)"
There are a number of nasty traps that lie in wait if you are not careful about using
\&\fIclose()\fR.  The first of these will bite you if you have been using \fIshutdown()\fR on your
sockets.  Since the \s-1SSL\s0 protocol mandates that a \s-1SSL\s0 \*(L"close notify\*(R" message be
sent before the socket is closed, a \fIshutdown()\fR that closes the socket's write channel
will cause the close call to hang.  For a similar reason, if you try to close a
copy of a socket (as in a forking server) you will affect the original socket as well.
To get around these problems, call close with an object-oriented syntax 
(e.g. \f(CW$socket\fR->close(SSL_no_shutdown => 1))
and one or more of the following parameters:
.RS 4
.Ip "SSL_no_shutdown" 2
.IX Item "SSL_no_shutdown"
If set to a true value, this option will make \fIclose()\fR not use the \fISSL_shutdown()\fR call
on the socket in question so that the close operation can complete without problems
if you have used \fIshutdown()\fR or are working on a copy of a socket.
.Ip "SSL_ctx_free" 2
.IX Item "SSL_ctx_free"
If you want to make sure that the \s-1SSL\s0 context of the socket is destroyed when
you close it, set this option to a true value.
.RE
.RS 4
.RE
.Ip "\fB\f(BIpeek()\fB\fR" 4
.IX Item "peek()"
This function has exactly the same syntax as \fIsysread()\fR, and performs nearly the same
task (reading data from the socket) but will not advance the read position so
that successive calls to \fIpeek()\fR with the same arguments will return the same results.
This function requires Net::SSLeay v1.19 or higher and OpenSSL 0.9.6a or later to work.
.Ip "\fB\f(BIpending()\fB\fR" 4
.IX Item "pending()"
This function will let you know how many bytes of data are immediately ready for reading
from the socket.  This is especially handy if you are doing reads on a blocking socket
or just want to know if new data has been sent over the socket.
.Ip "\fB\f(BIget_cipher()\fB\fR" 4
.IX Item "get_cipher()"
Returns the string form of the cipher that the \s-1IO:\s0:Socket::SSL object is using.
.Ip "\fB\f(BIdump_peer_certificate()\fB\fR" 4
.IX Item "dump_peer_certificate()"
Returns a parsable string with select fields from the peer \s-1SSL\s0 certificate.  This
method directly returns the result of the \fIdump_peer_certificate()\fR method of Net::SSLeay.
.Ip "\fBpeer_certificate($field)\fR" 4
.IX Item "peer_certificate($field)"
If a peer certificate exists, this function can retrieve values from it.  Right now, the
only fields it can return are \*(L"authority\*(R" and \*(L"owner\*(R" (or \*(L"issuer\*(R" and \*(L"subject\*(R" if
you want to use OpenSSL names), corresponding to the certificate authority that signed the
peer certificate and the owner of the peer certificate.  This function returns a string
with all the information about the particular field in one parsable line.
.Ip "\fB\f(BIerrstr()\fB\fR" 4
.IX Item "errstr()"
Returns the last error (in string form) that occurred.  If you do not have a real
object to perform this method on, call &\fIIO::Socket::SSL::errstr()\fR instead.
For read and write errors on non-blocking sockets, this method may include the string 
\&\f(CW\*(C`SSL wants a read first!\*(C'\fR or \f(CW\*(C`SSL wants a write first!\*(C'\fR meaning that the other side
is expecting to read from or write to the socket and wants to be satisfied before you
get to do anything.
.Ip "\fB\s-1IO:\s0:Socket::SSL->start_SSL($socket, ... )\fR" 4
.IX Item "IO::Socket::SSL->start_SSL($socket, ... )"
This will convert a glob reference or a socket that you provide to an \s-1IO:\s0:Socket::SSL
object.  You may also pass parameters to specify context or connection options as with
a call to \fInew()\fR.  If you are using this function on an \fIaccept()\fRed socket, you must
set the parameter \*(L"SSL_server\*(R" to 1, i.e. \s-1IO:\s0:Socket::SSL->start_SSL($socket, SSL_server => 1).
If you have a class that inherits from \s-1IO:\s0:Socket::SSL and you want the \f(CW$socket\fR to be blessed
into your own class instead, use MyClass->start_SSL($socket) to achieve the desired effect.
Note that if \fIstart_SSL()\fR fails in \s-1SSL\s0 negotiation, \f(CW$socket\fR will remain blessed in its original class.
.PP
The following methods are unsupported (not to mention futile!) and \s-1IO:\s0:Socket::SSL
will emit a large \fICROAK()\fR if you are silly enough to use them:
.Ip "truncate" 4
.IX Item "truncate"
.PD 0
.Ip "stat" 4
.IX Item "stat"
.Ip "ungetc" 4
.IX Item "ungetc"
.Ip "setbuf" 4
.IX Item "setbuf"
.Ip "setvbuf" 4
.IX Item "setvbuf"
.Ip "fdopen" 4
.IX Item "fdopen"
.PD
.SH "RETURN VALUES"
.IX Header "RETURN VALUES"
A few changes have gone into \s-1IO:\s0:Socket::SSL v0.93 and later with respect to
return values.  The behavior on success remains unchanged, but for \fIall\fR functions,
the return value on error is now an empty list.  Therefore, the return value will be
false in all contexts, but those who have been using the return values as arguments
to subroutines (like \f(CW\*(C`mysub(new IO::Socket::SSL(...), ...)\*(C'\fR) may run into problems.
The moral of the story: \fIalways\fR check the return values of these functions before
using them in any way that you consider meaningful.
.SH "IPv6"
.IX Header "IPv6"
Support for IPv6 with \s-1IO:\s0:Socket::SSL is highly experimental, as none of the author's
machines use IPv6 and hence he cannot test \s-1IO:\s0:Socket::SSL with them.  However, if
you consider yourself sufficiently ready for bug-reporting, pass the 'inet6' option
to \s-1IO:\s0:Socket::SSL when calling it (i.e. \f(CW\*(C`use IO::Socket::SSL qw(inet6);\*(C'\fR).  You will
need \s-1IO:\s0:Socket::INET6 to use this option.  If you absolutely do not want to use this
(or want a quick change back to IPv4), pass the 'inet4' option instead.
.SH "DEBUGGING"
.IX Header "DEBUGGING"
If you are having problems using \s-1IO:\s0:Socket::SSL despite the fact that can recite backwards
the section of this documentation labelled 'Using \s-1SSL\s0', you should try enabling debugging.  To
specify the debug level, pass 'debug#' (where # is a number from 0 to 4) to \s-1IO:\s0:Socket::SSL
when calling it:
.Ip "use \s-1IO:\s0:Socket::SSL qw(debug0);" 4
.IX Item "use IO::Socket::SSL qw(debug0);"
#No debugging (default).
.Ip "use \s-1IO:\s0:Socket::SSL qw(debug1);" 4
.IX Item "use IO::Socket::SSL qw(debug1);"
#Only print out errors.
.Ip "use \s-1IO:\s0:Socket::SSL qw(debug2);" 4
.IX Item "use IO::Socket::SSL qw(debug2);"
#Print out errors and cipher negotiation.
.Ip "use \s-1IO:\s0:Socket::SSL qw(debug3);" 4
.IX Item "use IO::Socket::SSL qw(debug3);"
#Print out progress, ciphers, and errors.
.Ip "use \s-1IO:\s0:Socket::SSL qw(debug4);" 4
.IX Item "use IO::Socket::SSL qw(debug4);"
#Print out everything, including data.
.PP
You can also set \f(CW$IO::Socket::SSL::DEBUG\fR to 0\-4, but that's a bit of a mouthful,
isn't it?
.SH "EXAMPLES"
.IX Header "EXAMPLES"
See the 'example' directory.
.SH "BUGS"
.IX Header "BUGS"
I have never shipped a module with a known bug, and \s-1IO:\s0:Socket::SSL is no
different.  If you feel that you have found a bug in the module and you are
using the latest versions of Net::SSLeay and OpenSSL, send an email immediately to 
<behrooz at fas.harvard.edu> with a subject of '\s-1IO:\s0:Socket::SSL Bug'.  I am 
\&\fInot responsible\fR for problems in your code, so make sure that an example
actually works before sending it. It is merely acceptable if you send me a bug 
report, it is better if you send a small chunk of code that points it out,
and it is best if you send a patch\*(--if the patch is good, you might see a release the 
next day on \s-1CPAN\s0. Otherwise, it could take weeks . . . 
.SH "LIMITATIONS"
.IX Header "LIMITATIONS"
\&\s-1IO:\s0:Socket::SSL uses Net::SSLeay as the shiny interface to OpenSSL, which is
the shiny interface to the ugliness of \s-1SSL\s0.  As a result, you will need both Net::SSLeay
and OpenSSL on your computer before using this module.
.SH "DEPRECATIONS"
.IX Header "DEPRECATIONS"
The following functions are deprecated and are only retained for compatibility:
.Ip "\fIcontext_init()\fR" 2
.IX Item "context_init()"
(use the SSL_reuse_ctx option if you want to re-use a context)
.Ip "\fIsocketToSSL()\fR and \fIsocket_to_SSL()\fR" 2
.IX Item "socketToSSL() and socket_to_SSL()"
(use \s-1IO:\s0:Socket::SSL->\fIstart_SSL()\fR instead)
.Ip "\fIget_peer_certificate()\fR and friends" 2
.IX Item "get_peer_certificate() and friends"
(use the \fIpeer_certificate()\fR function instead)
.Ip "\fIwant_read()\fR and \fIwant_write()\fR" 2
.IX Item "want_read() and want_write()"
(search for the appropriate string in \fIerrstr()\fR)
.PP
The following classes have been removed:
.Ip "\s-1SSL_SSL\s0" 2
.IX Item "SSL_SSL"
(not that you should have been directly accessing this anyway):
.Ip "X509_Certificate" 2
.IX Item "X509_Certificate"
(but \fIget_peer_certificate()\fR will still Do The Right Thing)
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\s-1IO:\s0:Socket::INET, \s-1IO:\s0:Socket::INET6, Net::SSLeay.
.SH "AUTHORS"
.IX Header "AUTHORS"
Peter Behroozi, <behrooz at fas.harvard.edu> (Note the lack of an \*(L"i\*(R" at the end of \*(L"behrooz\*(R")
.PP
Marko Asplund, <aspa at kronodoc.fi>, was the original author of \s-1IO:\s0:Socket::SSL.
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
The rewrite of this module is Copyright (C) 2002\-2003 Peter Behroozi.
.PP
This module is Copyright (C) 1999\-2002 Marko Asplund.
.PP
This module is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.
.SH "Appendix: Using SSL"
.IX Header "Appendix: Using SSL"
If you are unfamiliar with the way OpenSSL works, a good reference may be found in
both the book \*(L"Network Security with OpenSSL\*(R" (Oreilly & Assoc.) and the web site 
http://www.tldp.org/HOWTO/SSL-Certificates-HOWTO/.  Read on for a quick overview.
.Sh "The Long of It (Detail)"
.IX Subsection "The Long of It (Detail)"
The usual reason for using \s-1SSL\s0 is to keep your data safe.  This means that not only
do you have to encrypt the data while it is being transported over a network, but
you also have to make sure that the right person gets the data.  To accomplish this
with \s-1SSL\s0, you have to use certificates.  A certificate closely resembles a 
Government-issued \s-1ID\s0 (at least in places where you can trust them).  The \s-1ID\s0 contains some sort of
identifying information such as a name and address, and is usually stamped with a seal
of Government Approval.  Theoretically, this means that you may trust the information on
the card and do business with the owner of the card.  The same ideas apply to \s-1SSL\s0 certificates,
which have some identifying information and are \*(L"stamped\*(R" [most people refer to this as
\&\fIsigning\fR instead] by someone (a Certificate Authority) who you trust will adequately 
verify the identifying information.  In this case, because of some clever number theory,
it is extremely difficult to falsify the stamping process.  Another useful consequence
of number theory is that the certificate is linked to the encryption process, so you may
encrypt data (using information on the certificate) that only the certificate owner can
decrypt.
.PP
What does this mean for you?  It means that at least one person in the party has to
have an \s-1ID\s0 to get drinks :\-).  Seriously, it means that one of the people communicating
has to have a certificate to ensure that your data is safe.  For client/server
interactions, the server must \fBalways\fR have a certificate.  If the server wants to
verify that the client is safe, then the client must also have a personal certificate.
To verify that a certificate is safe, one compares the stamped \*(L"seal\*(R" [commonly called
an \fIencrypted digest/hash/signature\fR] on the certificate with the official \*(L"seal\*(R" of
the Certificate Authority to make sure that they are the same.  To do this, you will
need the [unfortunately named] certificate of the Certificate Authority.  With all these
in hand, you can set up a \s-1SSL\s0 connection and be reasonably confident that no-one is
reading your data.
.Sh "The Short of It (Summary)"
.IX Subsection "The Short of It (Summary)"
For servers, you will need to generate a cryptographic private key and a certificate
request.  You will need to send the certificate request to a Certificate Authority to
get a real certificate back, after which you can start serving people.  For clients,
you will not need anything unless the server wants validation, in which case you will
also need a private key and a real certificate.  For more information about how to
get these, see http://www.modssl.org/docs/2.8/ssl_faq.html#ToC24.
