.rn '' }`
''' $RCSfile: Crypt::CBC.3,v $$Revision: 1.1.1.1 $$Date: 2002-03-08 21:10:35 $
'''
''' $Log: not supported by cvs2svn $
'''
.de Sh
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp
.if t .sp .5v
.if n .sp
..
.de Ip
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.de Vb
.ft CW
.nf
.ne \\$1
..
.de Ve
.ft R

.fi
..
'''
'''
'''     Set up \*(-- to give an unbreakable dash;
'''     string Tr holds user defined translation string.
'''     Bell System Logo is used as a dummy character.
'''
.tr \(*W-|\(bv\*(Tr
.ie n \{\
.ds -- \(*W-
.ds PI pi
.if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\" diablo 12 pitch
.ds L" ""
.ds R" ""
'''   \*(M", \*(S", \*(N" and \*(T" are the equivalent of
'''   \*(L" and \*(R", except that they are used on ".xx" lines,
'''   such as .IP and .SH, which do another additional levels of
'''   double-quote interpretation
.ds M" """
.ds S" """
.ds N" """""
.ds T" """""
.ds L' '
.ds R' '
.ds M' '
.ds S' '
.ds N' '
.ds T' '
'br\}
.el\{\
.ds -- \(em\|
.tr \*(Tr
.ds L" ``
.ds R" ''
.ds M" ``
.ds S" ''
.ds N" ``
.ds T" ''
.ds L' `
.ds R' '
.ds M' `
.ds S' '
.ds N' `
.ds T' '
.ds PI \(*p
'br\}
.\"	If the F register is turned on, we'll generate
.\"	index entries out stderr for the following things:
.\"		TH	Title 
.\"		SH	Header
.\"		Sh	Subsection 
.\"		Ip	Item
.\"		X<>	Xref  (embedded
.\"	Of course, you have to process the output yourself
.\"	in some meaninful fashion.
.if \nF \{
.de IX
.tm Index:\\$1\t\\n%\t"\\$2"
..
.nr % 0
.rr F
.\}
.TH CBC 3 "perl 5.005, patch 03" "23/Jan/2002" "User Contributed Perl Documentation"
.UC
.if n .hy 0
.if n .na
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.de CQ          \" put $1 in typewriter font
.ft CW
'if n "\c
'if t \\&\\$1\c
'if n \\&\\$1\c
'if n \&"
\\&\\$2 \\$3 \\$4 \\$5 \\$6 \\$7
'.ft R
..
.\" @(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2
.	\" AM - accent mark definitions
.bd B 3
.	\" fudge factors for nroff and troff
.if n \{\
.	ds #H 0
.	ds #V .8m
.	ds #F .3m
.	ds #[ \f1
.	ds #] \fP
.\}
.if t \{\
.	ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.	ds #V .6m
.	ds #F 0
.	ds #[ \&
.	ds #] \&
.\}
.	\" simple accents for nroff and troff
.if n \{\
.	ds ' \&
.	ds ` \&
.	ds ^ \&
.	ds , \&
.	ds ~ ~
.	ds ? ?
.	ds ! !
.	ds /
.	ds q
.\}
.if t \{\
.	ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.	ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.	ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.	ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.	ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.	ds ? \s-2c\h'-\w'c'u*7/10'\u\h'\*(#H'\zi\d\s+2\h'\w'c'u*8/10'
.	ds ! \s-2\(or\s+2\h'-\w'\(or'u'\v'-.8m'.\v'.8m'
.	ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.	ds q o\h'-\w'o'u*8/10'\s-4\v'.4m'\z\(*i\v'-.4m'\s+4\h'\w'o'u*8/10'
.\}
.	\" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds v \\k:\h'-(\\n(.wu*9/10-\*(#H)'\v'-\*(#V'\*(#[\s-4v\s0\v'\*(#V'\h'|\\n:u'\*(#]
.ds _ \\k:\h'-(\\n(.wu*9/10-\*(#H+(\*(#F*2/3))'\v'-.4m'\z\(hy\v'.4m'\h'|\\n:u'
.ds . \\k:\h'-(\\n(.wu*8/10)'\v'\*(#V*4/10'\z.\v'-\*(#V*4/10'\h'|\\n:u'
.ds 3 \*(#[\v'.2m'\s-2\&3\s0\v'-.2m'\*(#]
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.ds oe o\h'-(\w'o'u*4/10)'e
.ds Oe O\h'-(\w'O'u*4/10)'E
.	\" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.	\" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.	ds : e
.	ds 8 ss
.	ds v \h'-1'\o'\(aa\(ga'
.	ds _ \h'-1'^
.	ds . \h'-1'.
.	ds 3 3
.	ds o a
.	ds d- d\h'-1'\(ga
.	ds D- D\h'-1'\(hy
.	ds th \o'bp'
.	ds Th \o'LP'
.	ds ae ae
.	ds Ae AE
.	ds oe oe
.	ds Oe OE
.\}
.rm #[ #] #H #V #F C
.SH "NAME"
Crypt::CBC \- Encrypt Data with Cipher Block Chaining Mode
.SH "SYNOPSIS"
.PP
.Vb 18
\&  use Crypt::CBC;
\&  $cipher = Crypt::CBC->new( {  'key'              => 'my secret key',
\&                                'cipher'           => 'Blowfish',
\&                                'iv'               => '$KJh#(}q',
\&                                'regenerate_key'   => 0,
\&                                'padding'          => 'space',
\&                                'prepend_iv'       => 0,
\&                        );
\&  
\&  $ciphertext = $cipher->encrypt("This data is hush hush");
\&  $plaintext = $cipher->decrypt($ciphertext);
\&  
\&  $cipher->start('encrypting');
\&  open(F,"./BIG_FILE");
\&  while (read(F,$buffer,1024)) {
\&      print $cipher->crypt($buffer);
\&  }
\&  print $cipher->finish;
.Ve
.SH "DESCRIPTION"
This module is a Perl-only implementation of the cryptographic cipher
block chaining mode (CBC).  In combination with a block cipher such as
DES or IDEA, you can encrypt and decrypt messages of arbitrarily long
length.  The encrypted messages are compatible with the encryption
format used by \fBSSLeay\fR.
.PP
To use this module, you will first create a new Crypt::CBC cipher object with
\fInew()\fR.  At the time of cipher creation, you specify an encryption key
to use and, optionally, a block encryption algorithm.  You will then
call the \fIstart()\fR method to initialize the encryption or decryption
process, \fIcrypt()\fR to encrypt or decrypt one or more blocks of data, and
lastly \fIfinish()\fR, to flush the encryption stream.  For your
convenience, you can call the \fIencrypt()\fR and \fIdecrypt()\fR methods to
operate on a whole data value at once.
.Sh "\fInew()\fR"
.PP
.Vb 10
\&  $cipher = Crypt::CBC->new( {  'key'              => 'my secret key',
\&                                'cipher'           => 'Blowfish',
\&                                'iv'               => '$KJh#(}q',
\&                                'regenerate_key'   => 0,        # default true
\&                                'padding'          => 'space',
\&                                'prepend_iv'       => 0,
\&                        );
\&  
\&  # or (for compatibility with earlier versions)
\&  $cipher = new Crypt::CBC($key,$algorithm);
.Ve
The \fInew()\fR method creates a new Crypt::\s-1CBC\s0 object.  
.PP
You must provide an encryption/decryption key, which can be any series
of characters of any length.  If regenerate_key is not specified as a
false value, the actual key used is derived from the \s-1MD5\s0 hash of the
key you provide.  The cipher is optional and will default to \s-1DES\s0 unless
specified otherwise.  It is the block encryption algorithm to use,
specified as a package name.  You may use any block encryption
algorithm that you have installed.  At the time this was written, only
three were available on \s-1CPAN\s0, Crypt::\s-1DES\s0, Crypt::\s-1IDEA\s0, and
Crypt::Blowfish.  You may refer to them using their full names
("Crypt::\s-1IDEA\s0") or in abbreviated form ("\s-1IDEA\s0").  An initialization
value may be specified, either by passing in a key of \*(L'iv\*(R' as an option
to new, or by calling \f(CW$cipher\fR\->\fIset_initialization_key\fR\|($iv) before
calling \f(CW$cipher\fR\->\fIstart()\fR.  The initialization value will be ignored in
decryption if the ciphertext is prepended by text which matches the
regex /^RandomIV.{8}/, in which case the 8 characters following
\*(L"RandomIV\*(R" will be used as the initialization value.  When encrypting,
by default the ciphertext will be prepended with \*(L"RandomIV<\s-1IV\s0>\*(R" (16 bytes);
to disable this, set prepend_iv to a false value. The padding
method can be specified by the optional \*(L'padding\*(R' argument to \fInew()\fR.
If no padding method is specified, null padding is assumed.
.Sh "\fIstart()\fR"
.PP
.Vb 2
\&   $cipher->start('encrypting');
\&   $cipher->start('decrypting');
.Ve
The \fIstart()\fR method prepares the cipher for a series of encryption or
decryption steps, resetting the internal state of the cipher if
necessary.  You must provide a string indicating whether you wish to
encrypt or decrypt.  \*(L"E\*(R" or any word that begins with an \*(L"e\*(R" indicates
encryption.  \*(L"D\*(R" or any word that begins with a \*(L"d\*(R" indicates
decryption.
.Sh "\fIcrypt()\fR      \f(CW$ciphertext\fR = \f(CW$cipher\fR\->\fIcrypt\fR\|($plaintext);"
After calling \fIstart()\fR, you should call \fIcrypt()\fR as many times as
necessary to encrypt the desired data.  
.Sh "\fIfinish()\fR"
.PP
.Vb 1
\&   $ciphertext = $cipher->finish();
.Ve
The \s-1CBC\s0 algorithm must buffer data blocks inernally until they are
even multiples of the encryption algorithm's blocksize (typically 8
bytes).  After the last call to \fIcrypt()\fR you should call \fIfinish()\fR.
This flushes the internal buffer and returns any leftover ciphertext.
.PP
In a typical application you will read the plaintext from a file or
input stream and write the result to standard output in a loop that
might look like this:
.PP
.Vb 4
\&  $cipher = new Crypt::CBC('hey jude!');
\&  $cipher->start('encrypting');
\&  print $cipher->crypt($_) while <>;
\&  print $cipher->finish();
.Ve
.Sh "\fIencrypt()\fR"
.PP
.Vb 1
\&  $ciphertext = $cipher->encrypt($plaintext)
.Ve
This convenience function runs the entire sequence of \fIstart()\fR, \fIcrypt()\fR
and \fIfinish()\fR for you, processing the provided plaintext and returning
the corresponding ciphertext.
.Sh "\fIdecrypt()\fR"
.PP
.Vb 1
\&  $plaintext = $cipher->decrypt($ciphertext)
.Ve
This convenience function runs the entire sequence of \fIstart()\fR, \fIcrypt()\fR
and \fIfinish()\fR for you, processing the provided ciphertext and returning
the corresponding plaintext.
.Sh "\fIencrypt_hex()\fR, \fIdecrypt_hex()\fR"
.PP
.Vb 2
\&  $ciphertext = $cipher->encrypt_hex($plaintext)
\&  $plaintext  = $cipher->decrypt_hex($ciphertext)
.Ve
These are convenience functions that operate on ciphertext in a
hexadecimal representation.  \fBencrypt_hex($plaintext)\fR is exactly
equivalent to \fBunpack('H*\*(R',encrypt($plaintext))\fR.  These functions
can be useful if, for example, you wish to place the encrypted
.Sh "\fIget_initialization_vector()\fR"
.PP
.Vb 1
\&  $iv = $cipher->get_initialization_vector()
.Ve
This function will return the initialization vector used in encryption
and or decryption.  This function may be useful to determine the
random initialization vector used when encrypting if none is specified
in \fInew()\fR.  The initialization vector is not guaranteed to be set when
encrypting until \fIstart()\fR is called, and when decrypting until \fIcrypt()\fR
is called the first time.
.Sh "\fIset_initialization_vector()\fR"
.PP
.Vb 1
\&  $cipher->set_initialization_vector('76543210')
.Ve
This function sets the initialization vector used in encryption
and or decryption.  This function may be useful if the initialization
vector is not contained within the ciphertext string being decrypted,
or if a particular initialization vector is desired when encrypting.
If the initialization vector 
random initialization vector used when encrypting if none is specified
in \fInew()\fR.  The initialization vector is not guaranteed to be set when
encrypting until \fIstart()\fR is called, and when decrypting until \fIcrypt()\fR
is called the first time.
.Sh "padding methods"
When the last block of the encoded output is less than the block size,
it will be padded.  Padding can take the form of \*(L"space\*(R" padding,
\*(L"null\*(R" padding, \*(L"oneandzeroes\*(R" padding, and a \*(L"standard\*(R" padding in
which the last block is padded with bytes representing the true size
of the block.  The \*(L"padding\*(R" option controls what type of padding to
use.  If none is provided, padding defaults to \*(L"standard\*(R".
.PP
Both the standard and oneandzeroes paddings are binary safe.  The
space and null paddings are recommended only for text data.  Which
type of padding you use depends on whether you wish to communicate
with an external (non Crypt::\s-1CBC\s0 library).  If this is the case, use
whatever padding method is compatible.
.PP
You can also pass in a custom padding function.  To do this, create a
function that takes the arguments:
.PP
.Vb 1
\&   $padded_block = function($block,$blocksize,$direction);
.Ve
where \f(CW$block\fR is the current block of data, \f(CW$blocksize\fR is the size to
pad it to, \f(CW$direction\fR is \*(L"e\*(R" for encrypting and \*(L"d\*(R" for decrypting,
and \f(CW$padded_block\fR is the result after padding or depadding.
.PP
when encrypting, the function should always return a string of
<blocksize> length, and when decrypting, can expect the string coming
in to always be that length. See _standard_padding, _space_padding,
_null_padding, or _oneandzeroes_padding in the source for examples.
.PP
Standard padding is recommended, as both space and null padding can
potentially truncate more characters than they should.  Future
versions of the module may include \s-1PKCS5\s0 / \s-1PKCS7\s0 padding support.
.SH "EXAMPLES"
Two examples, des.pl and idea.pl can be found in the eg/ subdirectory
of the Crypt-CBC distribution.  These implement command-line DES and
IDEA encryption algorithms.
.SH "LIMITATIONS"
The encryption and decryption process is about a tenth the speed of
the equivalent SSLeay programs (compiled C).  This could be improved
by implementing this module in C.  It may also be worthwhile to
optimize the DES and IDEA block algorithms further.
.SH "BUGS"
Please report them.
.SH "AUTHOR"
Lincoln Stein, lstein@cshl.org
.SH "SEE ALSO"
\fIperl\fR\|(1), \fICrypt::DES\fR\|(3), \fICrypt::IDEA\fR\|(3)

.rn }` ''
.IX Title "CBC 3"
.IX Name "Crypt::CBC - Encrypt Data with Cipher Block Chaining Mode"

.IX Header "NAME"

.IX Header "SYNOPSIS"

.IX Header "DESCRIPTION"

.IX Subsection "\fInew()\fR"

.IX Subsection "\fIstart()\fR"

.IX Subsection "\fIcrypt()\fR      \f(CW$ciphertext\fR = \f(CW$cipher\fR\->\fIcrypt\fR\|($plaintext);"

.IX Subsection "\fIfinish()\fR"

.IX Subsection "\fIencrypt()\fR"

.IX Subsection "\fIdecrypt()\fR"

.IX Subsection "\fIencrypt_hex()\fR, \fIdecrypt_hex()\fR"

.IX Subsection "\fIget_initialization_vector()\fR"

.IX Subsection "\fIset_initialization_vector()\fR"

.IX Subsection "padding methods"

.IX Header "EXAMPLES"

.IX Header "LIMITATIONS"

.IX Header "BUGS"

.IX Header "AUTHOR"

.IX Header "SEE ALSO"

