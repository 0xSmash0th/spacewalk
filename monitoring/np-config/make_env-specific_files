#!/usr/bin/perl -T

use IO::File;
use strict;

my $base      = "NOCpulse.ini";
my $src       = "$base.src";
my $dir       = "env-specific";
my $macrofile = "MACROS";
my @environments;
my @levels;
my %output;
my $current_section;


print "Starting ... \n";

open(SRC, $src) || die "Trying to open $src: $!";

# Read in the environments and security levels
while (<SRC>) {
  print;
  next if (/^\s+/);
  next if (/^\s*#/);

  if (/^ENVIRONMENTS/) {

    (undef, @environments) = split(/[:\s,]+/);
    if (scalar(@levels)) {
      &open_output_files();
      last;
    }

  } elsif (/^SECURITY_LEVELS/) {

    (undef, @levels) = split(/[:\s,]+/);
    if (scalar(@environments)) {
      &open_output_files();
      last;
    }

  }
}


# Process macros
my $macro = &read_macros($macrofile, \@environments);



# Process the rest of the source file, expanding macros
while (<SRC>) {
  print;
  next if (/^\s+/);
  next if (/^\s*#/);

  if (/^\[([^]]*)\]/) {

    $current_section = $1;
    &print_header($_);

  } else {

    my($sec, $env, $line) = split(/:\s*/, $_, 3);
    my @secs = ($sec eq 'ALL' ? @levels : $sec);
    my @envs = ($env eq 'ALL' ? @environments : $env);

    foreach my $tenv (@envs) {
      my $cooked;
      if ($line =~ /^\s*#/ or $line =~ /^\s*$/) {
        # No macro processing in comments or blank lines
        $cooked = $line;
      } else {
        $cooked = &process_macros($line, $macro->{$tenv}, $current_section);
      }
      foreach my $tsec (@secs) {
        &print_output_sec_env_line($tsec, $tenv, $cooked);
      }
    }

  }

}

close(SRC);
&close_output_files;



##############################################################################
###############################  Subroutines  ################################
##############################################################################

sub open_output_files {
  print "Opening Files ...\n";

  if (! -d $dir) {
    mkdir($dir, 0755) or die "Couldn't mkdir $dir: $!";
  }

  foreach my $sec (@levels) {

    my $subdir = &untaint("$dir/$sec");
    if (! -d $subdir) {
      mkdir($subdir, 0755) or die "Couldn't mkdir $subdir: $!";
    }

    foreach my $env (@environments) {
      my $fh = new IO::File;
      my $fname = &untaint("$subdir/${base}." . lc($env));
      $fh->open(">$fname") or die "Couldn't create $fname: $!";
      $output{$sec.$env} = $fh;
    }
  }
}

#----------------------------------------------------------

sub close_output_files {
  print "Closing Files ...\n";
  foreach my $key (keys(%output)) {
    $output{$key}->close();
  }
}

#----------------------------------------------------------

sub print_output_sec_env_line {
my $sec = shift;
  my $env = shift;
  my $line = shift;
  my $handle = $output{$sec.$env};
  chomp($line);
  $handle->print("$line\n");
}

#----------------------------------------------------------

sub print_header {
  my $line = shift;
  print_to_all_files("\n\n$line");
}

#----------------------------------------------------------

sub print_to_all_files {
  my $line = shift;
  foreach my $sec (@levels) {
    print_to_all_environments($sec, $line);
  }
}

#----------------------------------------------------------

sub print_to_all_levels
{
  my $env = shift;
  my $line = shift;
  foreach my $sec (@levels) {
    print_output_sec_env_line($sec, $env, $line);
  }
}

#----------------------------------------------------------

sub print_to_all_environments {
  my $sec = shift;
  my $line = shift;
  foreach my $env (@environments) {
    print_output_sec_env_line($sec, $env, $line);
  }
}

#----------------------------------------------------------

sub untaint {
  my($tainted, $pat) = @_;
  $pat ||= '[-\w\.\/]+';
  my $untainted;
  if ($tainted =~ /^($pat)$/) {
    $untainted = $1;
  } else {
    die "Couldn't untaint '$tainted' with /$pat/ -- pattern not matched\n";
  }
  return $untainted;
}

#----------------------------------------------------------

sub read_macros {

  my($file, $envs) = @_;
  my %macro;

  # Read in macro definitions
  open(FILE, "$file") or die "Couldn't open $file: $!";
  while (<FILE>) {
    next if (/^\s*$/);
    next if (/^\s*#/);
    chomp;
    my($targetenv, $macro) = split(/:\s*/, $_, 2);
    my($mname, $value)     = split(/=/, $macro, 2);

    foreach my $env ($targetenv eq 'ALL' ? @$envs : $targetenv) {
      $macro{$env}->{$mname} = $value;
    }

  }
  close(FILE);


  # Expand nested macros
  foreach my $env (@$envs) {
    my $mdb = $macro{$env};

    foreach my $macro (keys %$mdb) {
      my %seen;
      while ($mdb->{$macro} =~ /%{(\w+)}/mg) {
        my $submacro = $1;

        # Avoid recursive loops
        if ($seen{$submacro}++) {
          die "Macro expansion loop: macro '$macro' refers to '$submacro'";
        }

        if (exists($mdb->{$submacro})) {
          $mdb->{$macro} =~ s/%{$submacro}/$mdb->{$submacro}/;
        } else {
          die "Dangling reference %{$submacro}\n";
        }
      }
    }
  }

  return \%macro;

}


#----------------------------------------------------------

sub process_macros {

  my($line, $macro, $section) = @_;

  my($key, $value)  = split(/=/, $line, 2);

  # Store literal percents using OOB data
  $value =~ s/%%/\0/g;

  # Expand macros only on the value
  my %seen;
  while ($value =~ /%{(\w+)}/mg) {
    my $submacro = $1;

    # Avoid recursive loops
    if ($seen{$submacro}++) {
      die "$section.$key:  Macro expansion loop: " .
          "macro '$macro' refers to '$submacro'";
    }

    if (exists($macro->{$submacro})) {
      $value =~ s/%{$submacro}/$macro->{$submacro}/;
    } else {
      die "$section.$key:  Reference to nonexistent macro '$submacro'\n";
    }


  }

  # Retore literal percents as percent signs
  $value =~ s/\0/%/g;

  return join("=", $key, $value);
}
