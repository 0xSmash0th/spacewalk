From 7f25221f2098b3a7a779378f167df0b331b94315 Mon Sep 17 00:00:00 2001
From: Steve Milner <steve@tachikoman.(none)>
Date: Sun, 10 Aug 2008 17:04:48 -0400
Subject: [PATCH] moved common/rhnLib.py closer to pep8

---
 backend/common/rhnLib.py |  101 +++++++++++++++++++++++++++-------------------
 1 files changed, 59 insertions(+), 42 deletions(-)

diff --git a/backend/common/rhnLib.py b/backend/common/rhnLib.py
index 2216e1f..088feb1 100644
--- a/backend/common/rhnLib.py
+++ b/backend/common/rhnLib.py
@@ -7,10 +7,10 @@
 # FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2
 # along with this software; if not, see
 # http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.
-# 
+#
 # Red Hat trademarks are not licensed under GPLv2. No permission is
 # granted to use or replicate Red Hat trademarks that are incorporated
-# in this software or its documentation. 
+# in this software or its documentation.
 #
 
 import os
@@ -24,14 +24,18 @@ import popen2
 import select
 import urlparse
 
+
 ###############
 ### FUNCTIONS
 ###############
 
-# Function that correctly sets headers in an Apache-like table
-# The values may be a string (which are set as for a dictionary),
-# or an array.
+
 def setHeaderValue(mp_table, name, values):
+    """
+    Function that correctly sets headers in an Apache-like table
+    The values may be a string (which are set as for a dictionary),
+    or an array.
+    """
     # mp_table is an Apache mp_table (like headers_in or headers_out)
     # Sets the header name to the values
     if type(values) in (types.ListType, types.TupleType):
@@ -41,8 +45,10 @@ def setHeaderValue(mp_table, name, values):
         mp_table[name] = str(values)
 
 
-# Return time as a string formatted such as: 'Wed, 23 Jun 2001 23:08:35 GMT'.
 def rfc822time(arg):
+    """
+    Return time as a string formatted such as: 'Wed, 23 Jun 2001 23:08:35 GMT'.
+    """
     format = "%a, %d %b %Y %H:%M:%S GMT"
     if type(arg) in (types.ListType, types.TupleType):
         # Already a list
@@ -50,27 +56,28 @@ def rfc822time(arg):
     # Assume it's a float
     return time.strftime(format, time.gmtime(arg))
 
-##
-# Return time as a string formatted such as: 'Wed, 23 Jun 2001 23:08:35 GMT'.
-# We must not use locale-specific functions such as strftime here because
-# the RFC explicitly requires C-locale only formatting.  To satisfy this
-# requirement, we declare our own days and months here and do the formatting
-# manually.
-#
-# This function accepts a single argument.  If it is a List or Tuple type,
-# it is assumed to be of the form struct_time, as specified in the Python time
-# module reference.  If the argument is a float, it is expected to be the
-# number of seconds from the epoch.  
-#
-# NOTE:  In all cases, the argument is assumed to be in local time.  It will
-#        be translated to GMT in the return value.
-#
 
 rfc822_days = ('Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun')
 rfc822_mons = ('Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', \
                'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec')
 
+
 def rfc822time(arg):
+    """
+    Return time as a string formatted such as: 'Wed, 23 Jun 2001 23:08:35 GMT'.
+    We must not use locale-specific functions such as strftime here because
+    the RFC explicitly requires C-locale only formatting.  To satisfy this
+    requirement, we declare our own days and months here and do the formatting
+    manually.
+
+    This function accepts a single argument.  If it is a List or Tuple type,
+    it is assumed to be of the form struct_time, as specified in the Python
+    time module reference.  If the argument is a float, it is expected to be
+    the number of seconds from the epoch.
+
+    NOTE:  In all cases, the argument is assumed to be in local time.  It will
+           be translated to GMT in the return value.
+    """
 
     if type(arg) in (types.ListType, types.TupleType):
         # Convert to float.
@@ -87,8 +94,10 @@ def rfc822time(arg):
              tm_hour, tm_min, tm_sec, "GMT")
 
 
-# Converts the string in format YYYYMMDDHHMISS to seconds from the epoch
 def timestamp(s):
+    """
+    Converts the string in format YYYYMMDDHHMISS to seconds from the epoch
+    """
     if type(s) in (types.IntType, types.FloatType):
         # Presumably already a timestamp
         return s
@@ -124,7 +133,7 @@ def checkValue(val, *args):
 
 def cleanupAbsPath(path):
     """ take ~taw/../some/path/$MOUNT_POINT/blah and make it sensible.
-    
+
         Path return is absolute.
         NOTE: python 2.2 fixes a number of bugs with this and eliminates
               the need for os.path.expanduser
@@ -144,7 +153,6 @@ def cleanupNormPath(path):
         NOTE: python 2.2 fixes a number of bugs with this and eliminates
               the need for os.path.expanduser
     """
-
     if path is None:
         return None
     return os.path.normpath(
@@ -163,7 +171,7 @@ def parseUrl(url):
               that normally follows the URL, e.g. /XMLRPC
             - if {http[s],file}:// exists, anything between that and the next /
               is the URL.
-              
+
         The behavior of *this* function:
             - if no {http[s],file}:// then the string is simply assumed to be a
               URL without the {http[s],file}:// attached. The parsed info is
@@ -174,7 +182,6 @@ def parseUrl(url):
 
               NOTE: netloc (or network location) can be HOSTNAME:PORT
     """
-
     schemes = ('http', 'https')
     if url is None:
         return None
@@ -185,19 +192,23 @@ def parseUrl(url):
         parsed[0] = ''
     return tuple(parsed)
 
+
 class InvalidUrlError(Exception):
     pass
 
+
 def fix_url(url, scheme="http", path="/"):
     if string.lower(scheme) not in ('http', 'https'):
         # Programmer error
         raise ValueError("Unknown URL scheme %s" % scheme)
-    _scheme, _netloc, _path, _params, _query, _fragment = urlparse.urlparse(url)
+    _scheme, _netloc, _path, _params, _query, _fragment = \
+        urlparse.urlparse(url)
 
     if not _netloc:
         # No schema - trying to patch it up
         new_url = scheme + '://' + url
-        _scheme, _netloc, _path, _params, _query, _fragment = urlparse.urlparse(new_url)
+        _scheme, _netloc, _path, _params, _query, _fragment = \
+            urlparse.urlparse(new_url)
 
     if string.lower(_scheme) not in ('http', 'https'):
         raise InvalidUrlError("Invalid scheme %s for URL %s" % (_scheme, url))
@@ -212,6 +223,7 @@ def fix_url(url, scheme="http", path="/"):
         _fragment))
     return url
 
+
 def maketemp(prefix):
     """ Creates a temporary file (guaranteed to be new), using the
         specified prefix.
@@ -299,11 +311,11 @@ def rotateFile(filepath, depth=5, suffix='.', verbosity=0):
     if os.path.exists(pathNSuffix1) and os.path.isfile(pathNSuffix1) \
       and os.stat(filepath)[6] == os.stat(pathNSuffix1)[6] \
       and getFileMD5(filepath) == getFileMD5(pathNSuffix1):
-          # nothing to do
-          if verbosity:
-              sys.stderr.write("File '%s' is identical to it's rotation. "
-                               "Nothing to do.\n" % os.path.basename(filepath))
-          return None
+        # nothing to do
+        if verbosity:
+            sys.stderr.write("File '%s' is identical to it's rotation. "
+                             "Nothing to do.\n" % os.path.basename(filepath))
+        return None
 
     # find last in series (of rotations):
     last = 0
@@ -325,7 +337,8 @@ def rotateFile(filepath, depth=5, suffix='.', verbosity=0):
             path = '%s%d' % (pathNSuffix, i)
             os.unlink(path)
             if verbosity:
-                sys.stderr.write("Rotated out: '%s'\n" % os.path.basename(path))
+                sys.stderr.write("Rotated out: '%s'\n" % (
+                    os.path.basename(path)))
 
     # do the actual rotation
     shutil.copy2(filepath, pathNSuffix1)
@@ -349,7 +362,7 @@ def getFileMD5(filename=None, fd=None, file=None, buffer_size=None):
         buffer_size = 65536
 
     if filename is None and fd is None and file is None:
-        raise ValueError("no file specified");
+        raise ValueError("no file specified")
     if file:
         f = file
     elif fd is not None:
@@ -388,11 +401,11 @@ def rhn_popen(cmd, progressCallback=None, bufferSize=16384, outputLog=None):
     """ popen-like function, that accepts execvp-style arguments too (i.e. an
         array of params, thus making shell escaping unnecessary)
 
-        cmd can be either a string (like "ls -l /dev"), or an array of arguments
-        ["ls", "-l", "/dev"]
+        cmd can be either a string (like "ls -l /dev"), or an array of
+        arguments ["ls", "-l", "/dev"]
 
-        Returns the command's error code, a stream with stdout's contents and a 
-        stream with stderr's contents
+        Returns the command's error code, a stream with stdout's contents
+        and a stream with stderr's contents
 
         progressCallback --> progress bar twiddler
         outputLog --> optional log file file object write method
@@ -428,7 +441,8 @@ def rhn_popen(cmd, progressCallback=None, bufferSize=16384, outputLog=None):
                 # Some signal terminated this process
                 sig = os.WTERMSIG(status)
                 if outputLog is not None:
-                    outputLog("rhn_popen: terminated: Signal %s received\n" % sig)
+                    outputLog("rhn_popen: terminated: Signal %s received\n" % (
+                              sig))
                 exitcode = -sig
                 break
             elif os.WIFSTOPPED(status):
@@ -469,10 +483,14 @@ def rhn_popen(cmd, progressCallback=None, bufferSize=16384, outputLog=None):
 
     return exitcode, child_out, child_err
 
-# Trivial function that I wish existed in python 1.5
+
 def startswith(s, prefix):
+    """
+    Trivial function that I wish existed in python 1.5
+    """
     return s[:len(prefix)] == prefix
 
+
 def _test_parseUrl():
     print 'Testing parseUrl:'
     print '(addressing scheme, network location, path,'
@@ -484,4 +502,3 @@ def _test_parseUrl():
     print parseUrl('https://somehostname:123')
     print parseUrl('https://somehostname:123/ABCDE')
     print
-
-- 
1.5.5.1

